// Generated by Copilot

class PolyMindChat {
    constructor() {
        this.apiBaseUrl = window.location.origin;
        this.wsUrl = `ws://${window.location.host}/ws/chat`;
        this.messages = [];
        this.isTyping = false;
        this.selectedAgent = 'deepseek';
        this.websocket = null;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 5;
        
        // Logging v√† debugging
        this.messageStats = {
            sent: 0,
            received: 0,
            errors: 0,
            connections: 0,
            reconnects: 0
        };
        this.messageLog = [];
        this.enableDetailedLogging = true;
        
        this.init();
    }

    /**
     * Log chi ti·∫øt message v·ªõi timestamp v√† preview
     * @param {string} direction - 'SEND' ho·∫∑c 'RECEIVE'
     * @param {object} data - D·ªØ li·ªáu message
     * @param {string} status - 'SUCCESS' ho·∫∑c 'ERROR'
     */
    logMessage(direction, data, status = 'SUCCESS') {
        const timestamp = new Date().toISOString();
        const messageId = `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        
        const logEntry = {
            id: messageId,
            timestamp,
            direction,
            status,
            data: JSON.parse(JSON.stringify(data)), // Deep clone
            agent: this.selectedAgent,
            size: JSON.stringify(data).length,
            preview: this.getMessagePreview(data)
        };
        
        // Th√™m v√†o message log
        this.messageLog.push(logEntry);
        
        // Gi·ªõi h·∫°n s·ªë l∆∞·ª£ng log entries (gi·ªØ 100 entries g·∫ßn nh·∫•t)
        if (this.messageLog.length > 100) {
            this.messageLog = this.messageLog.slice(-100);
        }
        
        // Update stats
        if (direction === 'SEND') {
            this.messageStats.sent++;
        } else if (direction === 'RECEIVE') {
            this.messageStats.received++;
        }
        
        if (status === 'ERROR') {
            this.messageStats.errors++;
        }
        
        // Console logging v·ªõi m√†u s·∫Øc
        if (this.enableDetailedLogging) {
            const emoji = direction === 'SEND' ? 'üì§' : 'üì•';
            const statusEmoji = status === 'SUCCESS' ? '‚úÖ' : '‚ùå';
            const color = direction === 'SEND' ? '#4CAF50' : '#2196F3';
            
            console.group(`%c${emoji} ${direction} ${statusEmoji}`, `color: ${color}; font-weight: bold;`);
            console.log(`üïí Time: ${new Date(timestamp).toLocaleTimeString('vi-VN')}`);
            console.log(`üéØ Agent: ${this.selectedAgent}`);
            console.log(`üìè Size: ${logEntry.size} bytes`);
            console.log(`üëÄ Preview: ${logEntry.preview}`);
            console.log(`üì¶ Full Data:`, data);
            console.groupEnd();
        }
        
        return logEntry;
    }
    
    /**
     * T·∫°o preview ng·∫Øn g·ªçn c·ªßa message
     * @param {object} data - D·ªØ li·ªáu message
     * @returns {string} Preview string
     */
    getMessagePreview(data) {
        if (typeof data === 'string') {
            return data.substring(0, 50) + (data.length > 50 ? '...' : '');
        }
        
        if (data.content) {
            const content = data.content.substring(0, 50);
            return content + (data.content.length > 50 ? '...' : '');
        }
        
        if (data.type) {
            return `[${data.type}] ${JSON.stringify(data).substring(0, 30)}...`;
        }
        
        return JSON.stringify(data).substring(0, 50) + '...';
    }
    
    /**
     * Log k·∫øt n·ªëi WebSocket
     * @param {string} event - 'CONNECT', 'DISCONNECT', 'RECONNECT'
     * @param {object} details - Chi ti·∫øt b·ªï sung
     */
    logConnection(event, details = {}) {
        const timestamp = new Date().toISOString();
        
        const logEntry = {
            timestamp,
            event,
            details,
            readyState: this.websocket?.readyState,
            reconnectAttempts: this.reconnectAttempts,
            url: this.wsUrl
        };
        
        // Update stats
        if (event === 'CONNECT') {
            this.messageStats.connections++;
        } else if (event === 'RECONNECT') {
            this.messageStats.reconnects++;
        }
        
        // Console logging
        const eventEmojis = {
            'CONNECT': 'üîå',
            'DISCONNECT': 'üîå‚ùå',
            'RECONNECT': 'üîÑ'
        };
        
        const emoji = eventEmojis[event] || 'üîå';
        console.log(`%c${emoji} WebSocket ${event}`, 'color: #FF9800; font-weight: bold;', logEntry);
        
        return logEntry;
    }
    
    /**
     * L·∫•y th·ªëng k√™ chi ti·∫øt v·ªÅ messages
     * @returns {object} Statistics object
     */
    getMessageStats() {
        const now = Date.now();
        const oneHourAgo = now - (60 * 60 * 1000);
        const recentMessages = this.messageLog.filter(log => 
            new Date(log.timestamp).getTime() > oneHourAgo
        );
        
        return {
            ...this.messageStats,
            totalMessages: this.messageLog.length,
            recentMessages: recentMessages.length,
            averageMessageSize: this.messageLog.length > 0 ? 
                Math.round(this.messageLog.reduce((sum, log) => sum + log.size, 0) / this.messageLog.length) : 0,
            errorRate: this.messageStats.sent > 0 ? 
                Math.round((this.messageStats.errors / this.messageStats.sent) * 100) : 0,
            connectionStatus: this.websocket?.readyState === WebSocket.OPEN ? 'CONNECTED' : 'DISCONNECTED',
            uptime: this.getUptime()
        };
    }
    
    /**
     * L·∫•y th·ªùi gian ho·∫°t ƒë·ªông
     * @returns {string} Uptime string
     */
    getUptime() {
        if (!this.startTime) return 'Unknown';
        
        const uptime = Date.now() - this.startTime;
        const minutes = Math.floor(uptime / 60000);
        const seconds = Math.floor((uptime % 60000) / 1000);
        
        return `${minutes}m ${seconds}s`;
    }
    
    /**
     * Debug helper - in ra th·ªëng k√™ console
     */
    printStats() {
        const stats = this.getMessageStats();
        
        console.group('üìä PolyMind Chat Statistics');
        console.table(stats);
        console.groupEnd();
        
        return stats;
    }
    
    /**
     * Debug helper - in ra message log g·∫ßn ƒë√¢y
     * @param {number} limit - S·ªë l∆∞·ª£ng messages g·∫ßn nh·∫•t
     */
    printRecentMessages(limit = 10) {
        const recent = this.messageLog.slice(-limit);
        
        console.group(`üìã Recent Messages (${recent.length})`);
        recent.forEach(log => {
            const emoji = log.direction === 'SEND' ? 'üì§' : 'üì•';
            const statusEmoji = log.status === 'SUCCESS' ? '‚úÖ' : '‚ùå';
            console.log(`${emoji}${statusEmoji} [${new Date(log.timestamp).toLocaleTimeString()}] ${log.preview}`);
        });
        console.groupEnd();
        
        return recent;
    }

    init() {
        this.startTime = Date.now();
        this.setupEventListeners();
        this.setupTextarea();
        this.updateWelcomeTime();
        this.setupAgentSelector();
        this.connectWebSocket();
        this.setupSidebar();
        
        console.log('üß† PolyMind Chat initialized with enhanced logging');
        console.log('üí° Use debugChat() for debug helpers');
    }/**
     * Kh·ªüi t·∫°o WebSocket connection v·ªõi error handling c·∫£i ti·∫øn
     */    connectWebSocket() {
        try {
            console.log(`üîå [WebSocket] Attempting to connect to: ${this.wsUrl}`);
            this.websocket = new WebSocket(this.wsUrl);
            
            this.websocket.onopen = () => {
                console.log('‚úÖ [WebSocket] Connection established successfully');
                console.log(`üìä [WebSocket] Ready state: ${this.websocket.readyState}`);
                this.updateConnectionStatus('connected');
                this.reconnectAttempts = 0;
                
                // Th√™m animation cho status dot khi connected
                this.animateStatusDot('success');
                
                // Log k·∫øt n·ªëi th√†nh c√¥ng
                this.logConnection('CONNECT');
            };

            this.websocket.onmessage = (event) => {
                console.log('üì• [WebSocket] Message received from server:', {
                    timestamp: new Date().toISOString(),
                    dataSize: event.data.length,
                    rawData: event.data
                });
                
                try {
                    const data = JSON.parse(event.data);
                    console.log('üì¶ [WebSocket] Parsed message data:', {
                        type: data.type,
                        agent: data.agent,
                        model: data.model,
                        contentLength: data.content?.length || 0,
                        timestamp: data.timestamp
                    });
                    
                    // Log message nh·∫≠n ƒë∆∞·ª£c
                    this.logMessage('RECEIVE', data);
                    
                    this.handleWebSocketMessage(data);
                } catch (parseError) {
                    console.error('‚ùå [WebSocket] Failed to parse message:', parseError);
                    console.error('üîç [WebSocket] Raw message data:', event.data);
                }
            };

            this.websocket.onclose = () => {
                console.log('‚ùå [WebSocket] Connection closed');
                console.log(`üìä [WebSocket] Final ready state: ${this.websocket?.readyState || 'undefined'}`);
                console.log(`üîÑ [WebSocket] Reconnect attempt: ${this.reconnectAttempts}/${this.maxReconnectAttempts}`);
                
                this.updateConnectionStatus('disconnected');
                this.animateStatusDot('error');
                this.attemptReconnect();
                
                // Log ng·∫Øt k·∫øt n·ªëi
                this.logConnection('DISCONNECT');
            };

            this.websocket.onerror = (error) => {
                console.error('ÔøΩ [WebSocket] Connection error occurred:', {
                    timestamp: new Date().toISOString(),
                    error: error,
                    readyState: this.websocket?.readyState,
                    url: this.wsUrl
                });
                this.updateConnectionStatus('disconnected');
                this.animateStatusDot('error');
            };

        } catch (error) {
            console.error('üö® [WebSocket] Failed to initialize connection:', error);
            this.updateConnectionStatus('disconnected');
            this.animateStatusDot('error');
        }
    }

    attemptReconnect() {
        if (this.reconnectAttempts < this.maxReconnectAttempts) {
            this.reconnectAttempts++;
            this.updateConnectionStatus('connecting');
            
            setTimeout(() => {
                console.log(`üîÑ Reconnect attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts}`);
                this.connectWebSocket();
            }, 2000 * this.reconnectAttempts);
        }
    }    handleWebSocketMessage(data) {
        console.log('üéØ [WebSocket] Processing received message:', {
            timestamp: new Date().toISOString(),
            rawData: data
        });

        // Handle format t·ª´ sandbox server: {"sender": "ai", "message": "..."}
        if (data.sender && data.message) {
            console.log('üí¨ [WebSocket] Handling server response format:', {
                sender: data.sender,
                messagePreview: data.message.substring(0, 100) + (data.message.length > 100 ? '...' : '')
            });
            
            this.hideTyping();
            
            switch(data.sender) {
                case 'ai':
                    this.addMessage(data.message, 'ai');
                    break;
                case 'system':
                    this.addMessage(data.message, 'ai', true);
                    break;
                default:
                    this.addMessage(data.message, 'ai');
                    break;
            }
            return;
        }

        // Handle format c≈© v·ªõi type: {"type": "ai_response", "content": "..."}
        console.log('üéØ [WebSocket] Processing message with type format:', {
            messageType: data.type,
            agent: data.agent,
            model: data.model,
            hasContent: !!data.content,
            contentLength: data.content?.length || 0
        });

        switch(data.type) {
            case 'ai_response':
                console.log('üí¨ [WebSocket] Handling AI response:', {
                    agent: data.agent,
                    model: data.model,
                    contentPreview: data.content?.substring(0, 100) + (data.content?.length > 100 ? '...' : ''),
                    serverTimestamp: data.timestamp
                });
                this.hideTyping();
                this.addMessage(data.content, 'ai');
                break;
                
            case 'ai_typing':
                console.log('‚å®Ô∏è [WebSocket] Agent typing indicator:', {
                    agent: data.agent,
                    serverTimestamp: data.timestamp
                });
                // Handle typing indicator if needed
                break;
                
            case 'ai_chunk':
                console.log('üìù [WebSocket] Received streaming chunk:', {
                    agent: data.agent,
                    chunkLength: data.content?.length || 0,
                    serverTimestamp: data.timestamp
                });
                // Handle streaming chunks if needed
                break;
                
            case 'error':
                console.error('üö® [WebSocket] Server error received:', {
                    errorContent: data.content,
                    serverTimestamp: data.timestamp
                });
                this.hideTyping();
                this.addMessage(data.content || 'ƒê√£ x·∫£y ra l·ªói t·ª´ server', 'ai', true);
                break;
                
            default:
                console.warn('‚ùì [WebSocket] Unknown message type:', {
                    type: data.type,
                    data: data
                });
                break;
        }
    }/**
     * C·∫≠p nh·∫≠t tr·∫°ng th√°i k·∫øt n·ªëi v·ªõi UI c·∫£i ti·∫øn
     * @param {string} status - Tr·∫°ng th√°i k·∫øt n·ªëi ('connected', 'disconnected', 'connecting')
     */
    updateConnectionStatus(status) {
        const connectionStatus = document.getElementById('connectionStatus');
        const statusText = document.getElementById('statusText');
        
        if (!connectionStatus) return;
        
        connectionStatus.className = `connection-status ${status}`;
        
        // Map tr·∫°ng th√°i sang text ti·∫øng Vi·ªát
        const statusMessages = {
            'connected': 'ƒê√£ k·∫øt n·ªëi',
            'disconnected': 'M·∫•t k·∫øt n·ªëi',
            'connecting': 'ƒêang k·∫øt n·ªëi...'
        };
        
        const message = statusMessages[status] || 'Kh√¥ng x√°c ƒë·ªãnh';
        
        // C·∫≠p nh·∫≠t tooltip
        connectionStatus.setAttribute('data-status', message);
        
        // C·∫≠p nh·∫≠t text element n·∫øu c√≥
        if (statusText) {
            statusText.textContent = message;
        }
        
        // Log cho debugging
        console.log(`üîå Connection status: ${status} (${message})`);
    }    setupEventListeners() {
        // Chat form submission
        const chatForm = document.getElementById('chat-form');
        if (chatForm) {
            chatForm.addEventListener('submit', (e) => {
                e.preventDefault();
                this.sendMessage();
            });
        }

        // Textarea auto-resize and shortcuts
        const chatInput = document.getElementById('chat-input');
        if (chatInput) {
            chatInput.addEventListener('input', () => {
                this.updateCharCount();
                this.autoResizeTextarea();
                this.updateSendButton();
            });

            chatInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    this.sendMessage();
                }
            });
        }

        // Send button (using class selector since no ID)
        const sendButton = document.querySelector('.send-btn');
        if (sendButton) {
            sendButton.addEventListener('click', () => {
                this.sendMessage();
            });
        }
    }    setupTextarea() {
        const chatInput = document.getElementById('chat-input');
        if (chatInput) {
            chatInput.style.height = 'auto';
            this.updateSendButton();
        }
    }    setupAgentSelector() {
        const agentSelector = document.getElementById('agentSelector');
        if (agentSelector) {
            agentSelector.addEventListener('change', (e) => {
                this.selectedAgent = e.target.value;
                this.addSystemMessage(`ƒê√£ chuy·ªÉn sang ${e.target.options[e.target.selectedIndex].text}`);
            });
        }
    }

    updateWelcomeTime() {
        const welcomeTime = document.getElementById('welcomeTime');
        if (welcomeTime) {
            welcomeTime.textContent = new Date().toLocaleTimeString('vi-VN');
        }
    }    updateCharCount() {
        const chatInput = document.getElementById('chat-input');
        const charCount = document.getElementById('charCount');
        
        if (!chatInput || !charCount) return;
        
        const currentLength = chatInput.value.length;
        const maxLength = parseInt(chatInput.getAttribute('maxlength')) || 2000;
        
        charCount.textContent = `${currentLength}/${maxLength}`;
        
        // Change color if approaching limit
        if (currentLength > maxLength * 0.8) {
            charCount.style.color = 'var(--warning-color)';
        } else if (currentLength > maxLength * 0.9) {
            charCount.style.color = 'var(--error-color)';
        } else {
            charCount.style.color = 'var(--text-light)';
        }
    }    autoResizeTextarea() {
        const chatInput = document.getElementById('chat-input');
        if (chatInput) {
            chatInput.style.height = 'auto';
            chatInput.style.height = Math.min(chatInput.scrollHeight, 120) + 'px';
        }
    }    updateSendButton() {
        const chatInput = document.getElementById('chat-input');
        const sendButton = document.querySelector('.send-btn');
        
        if (!chatInput || !sendButton) return;
        
        const hasText = chatInput.value.trim().length > 0;
        
        sendButton.disabled = !hasText || this.isTyping;
    }    async sendMessage() {
        const chatInput = document.getElementById('chat-input');
        const message = chatInput.value.trim();
        
        if (!message || this.isTyping || !chatInput) return;

        // Check WebSocket connection
        if (!this.websocket || this.websocket.readyState !== WebSocket.OPEN) {
            this.addMessage('K·∫øt n·ªëi b·ªã gi√°n ƒëo·∫°n. ƒêang th·ª≠ k·∫øt n·ªëi l·∫°i...', 'ai', true);
            this.connectWebSocket();
            return;
        }

        // Add user message
        this.addMessage(message, 'user');
        
        // Clear input
        chatInput.value = '';
        this.updateCharCount();
        this.autoResizeTextarea();
        this.updateSendButton();

        // Show typing indicator
        this.showTyping();        try {
            // Send message via WebSocket - s·ª≠ d·ª•ng format m√† server expect
            const messageData = {
                message: message,  // ƒê·ªïi t·ª´ 'content' th√†nh 'message' ƒë·ªÉ match v·ªõi server
                agent: this.selectedAgent,
                timestamp: new Date().toISOString()
            };
            
            console.log('üì§ [WebSocket] Sending message to server:', {
                timestamp: new Date().toISOString(),
                messageLength: message.length,
                agent: this.selectedAgent,
                readyState: this.websocket.readyState,
                messagePreview: message.substring(0, 100) + (message.length > 100 ? '...' : ''),
                fullData: messageData
            });
            
            // Log message g·ª≠i ƒëi
            this.logMessage('SEND', messageData);
            
            this.websocket.send(JSON.stringify(messageData));
            
            console.log('‚úÖ [WebSocket] Message sent successfully');
            
        } catch (error) {
            console.error('‚ùå [WebSocket] Error sending message:', {
                timestamp: new Date().toISOString(),
                error: error,
                message: error.message,
                readyState: this.websocket?.readyState,
                messageLength: message.length
            });
            this.hideTyping();
            this.addMessage('Xin l·ªói, ƒë√£ c√≥ l·ªói x·∫£y ra. Vui l√≤ng th·ª≠ l·∫°i.', 'ai', true);
        }
    }    addMessage(content, sender, isError = false) {
        const chatMessages = document.getElementById('chat-log');
        if (!chatMessages) return;
        
        const messageDiv = document.createElement('div');
        const timestamp = new Date().toLocaleTimeString('vi-VN');
        const messageId = 'msg_' + Date.now();

        messageDiv.className = `message ${sender}`;
        messageDiv.id = messageId;

        const avatarContent = sender === 'user' ? 
            '<i class="fas fa-user"></i>' : 
            '<i class="fas fa-robot"></i>';

        const senderName = sender === 'user' ? 'B·∫°n' : 'AI Assistant';
        const messageClass = isError ? 'error-message' : '';

        messageDiv.innerHTML = `
            <div class="message-avatar">
                ${avatarContent}
            </div>
            <div class="message-bubble">
                <div class="message-content ${messageClass}">
                    ${this.formatMessage(content)}
                </div>
                <div class="message-time">${senderName} ‚Ä¢ ${timestamp}</div>
            </div>
        `;

        // Insert before typing indicator
        const typingIndicator = document.getElementById('typing-indicator');
        if (typingIndicator) {
            chatMessages.insertBefore(messageDiv, typingIndicator);
        } else {
            chatMessages.appendChild(messageDiv);
        }

        // Animate message appearance
        messageDiv.style.opacity = '0';
        messageDiv.style.transform = 'translateY(20px)';
        
        setTimeout(() => {
            messageDiv.style.opacity = '1';
            messageDiv.style.transform = 'translateY(0)';
        }, 10);

        // Scroll to bottom
        this.scrollToBottom();

        // Store message
        this.messages.push({
            id: messageId,
            content,
            sender,
            timestamp: Date.now(),
            agent: this.selectedAgent
        });
    }    addSystemMessage(content) {
        const chatMessages = document.getElementById('chat-log');
        if (!chatMessages) return;
        
        const messageDiv = document.createElement('div');
        
        messageDiv.innerHTML = `
            <div style="text-align: center; margin: var(--spacing-md) 0;">
                <div style="display: inline-block; background: var(--bg-primary); color: var(--text-secondary); padding: var(--spacing-xs) var(--spacing-md); border-radius: 20px; font-size: 0.875rem;">
                    <i class="fas fa-info-circle"></i> ${content}
                </div>
            </div>
        `;

        const typingIndicator = document.getElementById('typing-indicator');
        if (typingIndicator) {
            chatMessages.insertBefore(messageDiv, typingIndicator);
        } else {
            chatMessages.appendChild(messageDiv);
        }
        this.scrollToBottom();
    }

    formatMessage(content) {
        // Basic message formatting
        return content
            .replace(/\n/g, '<br>')
            .replace(/`([^`]+)`/g, '<code>$1</code>')
            .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
            .replace(/\*([^*]+)\*/g, '<em>$1</em>');
    }    showTyping() {
        this.isTyping = true;
        const typingIndicator = document.getElementById('typing-indicator');
        if (typingIndicator) {
            typingIndicator.style.display = 'flex';
        }
        this.updateSendButton();
        this.scrollToBottom();
    }

    hideTyping() {
        this.isTyping = false;
        const typingIndicator = document.getElementById('typing-indicator');
        if (typingIndicator) {
            typingIndicator.style.display = 'none';
        }
        this.updateSendButton();
    }

    async simulateAIResponse(userMessage) {
        // Simulate processing time
        await new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 2000));

        // Generate response based on agent type and user message
        const response = this.generateAIResponse(userMessage);
        this.addMessage(response, 'ai');
    }    generateAIResponse(userMessage) {
        const responses = {
            deepseek: [
                `C·∫£m ∆°n b·∫°n ƒë√£ h·ªèi "${userMessage}". T√¥i s·∫Ω s·ª≠ d·ª•ng DeepSeek V3 ƒë·ªÉ ph√¢n t√≠ch v√† tr·∫£ l·ªùi chi ti·∫øt.`,
                `ƒê√¢y l√† m·ªôt c√¢u h·ªèi th√∫ v·ªã v·ªÅ "${userMessage}". V·ªõi kh·∫£ nƒÉng reasoning m·∫°nh m·∫Ω, t√¥i s·∫Ω ƒë∆∞a ra c√¢u tr·∫£ l·ªùi to√†n di·ªán.`,
                `T√¥i hi·ªÉu b·∫°n mu·ªën bi·∫øt v·ªÅ "${userMessage}". DeepSeek V3 s·∫Ω gi√∫p t√¥i cung c·∫•p insights s√¢u s·∫Øc v·ªÅ v·∫•n ƒë·ªÅ n√†y.`
            ],
            coding: [
                `V·ªÅ v·∫•n ƒë·ªÅ l·∫≠p tr√¨nh "${userMessage}", t√¥i s·∫Ω gi√∫p b·∫°n v·ªõi code example v√† best practices.`,
                `ƒê√¢y l√† m·ªôt c√¢u h·ªèi technical hay v·ªÅ "${userMessage}". H√£y ƒë·ªÉ t√¥i gi·∫£i th√≠ch chi ti·∫øt.`,
                `T√¥i s·∫Ω h·ªó tr·ª£ b·∫°n v·ªõi "${userMessage}" b·∫±ng c√°ch ƒë∆∞a ra solution v√† gi·∫£i th√≠ch t·ª´ng b∆∞·ªõc.`
            ],
            analysis: [
                `T√¥i s·∫Ω ph√¢n t√≠ch d·ªØ li·ªáu v·ªÅ "${userMessage}" v√† ƒë∆∞a ra insights quan tr·ªçng.`,
                `V·ªÅ "${userMessage}", t√¥i s·∫Ω th·ª±c hi·ªán analysis chi ti·∫øt v√† ƒë∆∞a ra recommendations.`,
                `D·ª±a tr√™n "${userMessage}", t√¥i s·∫Ω cung c·∫•p data-driven insights v√† visualizations.`
            ],
            creative: [
                `T√¥i s·∫Ω s√°ng t·∫°o n·ªôi dung v·ªÅ "${userMessage}" v·ªõi style ƒë·ªôc ƒë√°o v√† engaging.`,
                `V·ªÅ ch·ªß ƒë·ªÅ "${userMessage}", t√¥i s·∫Ω vi·∫øt m·ªôt c√°ch creative v√† compelling.`,
                `H√£y ƒë·ªÉ t√¥i t·∫°o ra n·ªôi dung th√∫ v·ªã v·ªÅ "${userMessage}" v·ªõi g√≥c nh√¨n m·ªõi m·∫ª.`
            ]
        };

        const agentResponses = responses[this.selectedAgent] || responses.deepseek;
        const randomResponse = agentResponses[Math.floor(Math.random() * agentResponses.length)];
        
        return randomResponse + '\n\nB·∫°n c√≥ mu·ªën t√¥i gi·∫£i th√≠ch th√™m chi ti·∫øt v·ªÅ v·∫•n ƒë·ªÅ n√†y kh√¥ng?';
    }    scrollToBottom() {
        const chatMessages = document.getElementById('chat-log');
        if (chatMessages) {
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
    }    clearChat() {
        const chatMessages = document.getElementById('chat-log');
        if (!chatMessages) return;
        
        const messages = chatMessages.querySelectorAll('.message');
        
        messages.forEach(message => {
            if (!message.classList.contains('ai') || message.querySelector('.message-content p')) {
                message.remove();
            }
        });

        this.messages = [];
        this.addSystemMessage('ƒê√£ x√≥a l·ªãch s·ª≠ chat');
    }

    /**
     * T·∫°o animation cho status dot
     * @param {string} type - Lo·∫°i animation ('success', 'error', 'warning')
     */
    animateStatusDot(type) {
        const statusDot = document.querySelector('.status-dot');
        if (!statusDot) return;
        
        // X√≥a animation c≈©
        statusDot.classList.remove('animate-success', 'animate-error', 'animate-warning');
        
        // Th√™m animation m·ªõi
        statusDot.classList.add(`animate-${type}`);
        
        // X√≥a class animation sau khi ho√†n th√†nh
        setTimeout(() => {
            statusDot.classList.remove(`animate-${type}`);
        }, 600);
    }

    /**
     * Toggle sidebar visibility tr√™n mobile
     */    toggleSidebar() {
        const sidebar = document.querySelector('.sidebar');
        const overlay = document.querySelector('.sidebar-overlay');
        
        if (!sidebar) return;
        
        sidebar.classList.toggle('open');
        
        // T·∫°o overlay n·∫øu ch∆∞a c√≥
        if (!overlay) {
            const newOverlay = document.createElement('div');
            newOverlay.className = 'sidebar-overlay';
            newOverlay.addEventListener('click', () => this.closeSidebar());
            document.body.appendChild(newOverlay);
        }
        
        // Toggle overlay
        const currentOverlay = document.querySelector('.sidebar-overlay');
        if (sidebar.classList.contains('open')) {
            currentOverlay?.classList.add('show');
            document.body.style.overflow = 'hidden'; // Prevent scroll
        } else {
            currentOverlay?.classList.remove('show');
            document.body.style.overflow = '';
        }
    }    /**
     * ƒê√≥ng sidebar
     */
    closeSidebar() {
        const sidebar = document.querySelector('.sidebar');
        const overlay = document.querySelector('.sidebar-overlay');
        
        sidebar?.classList.remove('open');
        overlay?.classList.remove('show');
        document.body.style.overflow = '';
    }    /**
     * Setup sidebar event listeners
     */
    setupSidebar() {
        // Mobile menu toggle button
        const mobileMenuBtn = document.getElementById('mobile-menu-toggle');
        if (mobileMenuBtn) {
            mobileMenuBtn.addEventListener('click', () => this.toggleSidebar());
        }

        // Close sidebar when clicking outside on mobile
        document.addEventListener('click', (e) => {
            const sidebar = document.querySelector('.sidebar');
            const mobileMenuBtn = document.getElementById('mobile-menu-toggle');
            
            if (window.innerWidth <= 768 && 
                sidebar?.classList.contains('open') &&
                !sidebar.contains(e.target) &&
                e.target !== mobileMenuBtn &&
                !mobileMenuBtn?.contains(e.target)) {
                this.closeSidebar();
            }
        });

        // Handle escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                this.closeSidebar();
            }
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            if (window.innerWidth > 768) {
                this.closeSidebar();
            }
        });

        // Setup chat history items
        this.setupChatHistory();
    }/**
     * Setup chat history functionality
     */
    setupChatHistory() {
        const historyItems = document.querySelectorAll('.chat-item');
        historyItems.forEach(item => {
            // Click handler
            item.addEventListener('click', (e) => {
                this.handleChatItemSelection(e, item, historyItems);
            });
            
            // Keyboard handler for accessibility
            item.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    this.handleChatItemSelection(e, item, historyItems);
                }
            });
        });
    }

    /**
     * Handle chat item selection (click or keyboard)
     */
    handleChatItemSelection(e, item, historyItems) {
        e.preventDefault();
        
        // Remove active class from all items
        historyItems.forEach(i => i.classList.remove('active'));
        
        // Add active class to selected item
        item.classList.add('active');
        
        // Load chat history (placeholder)
        const chatId = item.dataset.chatId || item.querySelector('.chat-item-title')?.textContent || 'unknown';
        this.loadChatHistory(chatId);
        
        // Close sidebar on mobile after selection
        if (window.innerWidth <= 768) {
            this.closeSidebar();
        }
    }

    /**
     * Load chat history (placeholder)
     * @param {string} chatId - ID c·ªßa chat c·∫ßn load
     */
    loadChatHistory(chatId) {
        // TODO: Implement actual chat history loading
        console.log(`Loading chat history: ${chatId}`);
        this.addSystemMessage(`ƒê√£ chuy·ªÉn sang cu·ªôc tr√≤ chuy·ªán: ${chatId}`);
    }

    /**
     * Get debug information for troubleshooting
     * @returns {Object} Debug information object
     */
    getDebugInfo() {
        return {
            websocket: {
                url: this.wsUrl,
                readyState: this.websocket?.readyState,
                readyStateText: this.getReadyStateText(),
                isConnected: this.websocket?.readyState === WebSocket.OPEN,
                reconnectAttempts: this.reconnectAttempts,
                maxReconnectAttempts: this.maxReconnectAttempts
            },
            chat: {
                selectedAgent: this.selectedAgent,
                messageCount: this.messages.length,
                isTyping: this.isTyping,
                lastMessage: this.messages[this.messages.length - 1]
            },
            session: {
                startTime: this.sessionStartTime || 'Not recorded',
                uptime: this.sessionStartTime ? Date.now() - this.sessionStartTime : 0
            }
        };
    }

    /**
     * Get human-readable WebSocket ready state
     * @returns {string} Ready state description
     */
    getReadyStateText() {
        if (!this.websocket) return 'Not initialized';
        
        const states = {
            [WebSocket.CONNECTING]: 'CONNECTING',
            [WebSocket.OPEN]: 'OPEN',
            [WebSocket.CLOSING]: 'CLOSING',
            [WebSocket.CLOSED]: 'CLOSED'
        };
        
        return states[this.websocket.readyState] || 'UNKNOWN';
    }

    /**
     * Log comprehensive session statistics
     */
    logSessionStats() {
        const stats = {
            timestamp: new Date().toISOString(),
            session: {
                duration: this.sessionStartTime ? Date.now() - this.sessionStartTime : 0,
                messagesSent: this.messages.filter(m => m.sender === 'user').length,
                messagesReceived: this.messages.filter(m => m.sender === 'ai').length,
                reconnectAttempts: this.reconnectAttempts
            },
            connection: {
                currentState: this.getReadyStateText(),
                url: this.wsUrl,
                selectedAgent: this.selectedAgent
            },
            performance: {
                totalMessages: this.messages.length,
                averageMessageLength: this.messages.reduce((sum, msg) => sum + msg.content.length, 0) / this.messages.length || 0
            }
        };

        console.log('üìä [Session] Comprehensive statistics:', stats);
        return stats;
    }

    // ...existing code...
}

// Global functions for HTML onclick handlers
window.clearChat = function() {
    if (window.polymindChat) {
        if (confirm('B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a to√†n b·ªô l·ªãch s·ª≠ chat?')) {
            window.polymindChat.clearChat();
        }
    }
};

window.exportChat = function() {
    if (window.polymindChat) {
        window.polymindChat.exportChat();
    }
};

// Global debugging functions
window.debugChat = function() {
    if (window.polymindChat) {
        const debugInfo = window.polymindChat.getDebugInfo();
        console.log('üîç [Debug] Chat debug information:', debugInfo);
        return debugInfo;
    } else {
        console.warn('‚ö†Ô∏è [Debug] PolyMind chat not initialized');
        return null;
    }
};

window.chatStats = function() {
    if (window.polymindChat) {
        return window.polymindChat.logSessionStats();
    } else {
        console.warn('‚ö†Ô∏è [Debug] PolyMind chat not initialized');
        return null;
    }
};

window.testWebSocket = function() {
    if (window.polymindChat && window.polymindChat.websocket) {
        const ws = window.polymindChat.websocket;
        console.log('üß™ [Test] WebSocket test message:', {
            readyState: ws.readyState,
            readyStateText: window.polymindChat.getReadyStateText(),
            url: ws.url
        });
        
        if (ws.readyState === WebSocket.OPEN) {
            const testMessage = {
                content: "Test message from browser console",
                agent: window.polymindChat.selectedAgent,
                timestamp: new Date().toISOString()
            };
            ws.send(JSON.stringify(testMessage));
            console.log('‚úÖ [Test] Test message sent successfully');
        } else {
            console.warn('‚ö†Ô∏è [Test] WebSocket not in OPEN state');
        }
    } else {
        console.warn('‚ö†Ô∏è [Test] WebSocket not available');
    }
};

// Initialize chat when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    window.polymindChat = new PolyMindChat();        // Add keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Ctrl/Cmd + K to focus input
            if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
                e.preventDefault();
                const chatInput = document.getElementById('chat-input');
                if (chatInput) chatInput.focus();
            }
            
            // Escape to blur input
            if (e.key === 'Escape') {
                const chatInput = document.getElementById('chat-input');
                if (chatInput) chatInput.blur();
            }
        });
});

// Expose for debugging
window.PolyMindChat = {
    instance: null,
    version: '1.0.0',
    debug: () => window.polymindChat ? window.polymindChat.getDebugInfo() : null,
    stats: () => window.polymindChat ? window.polymindChat.logSessionStats() : null,
    testWS: () => window.testWebSocket(),    /**
     * Helper method for debugging
     */
    help() {
        console.log(`
üß† PolyMind Chat Debug Console Help

üìä Statistics & Info:
- debugChat()               - Get debug information
- chatStats()               - Get session statistics  
- window.chat.printStats()  - Print detailed stats table
- window.chat.printRecentMessages(10) - Print recent messages

üîß Testing & Utils:
- testWebSocket()           - Send test message via WebSocket
- window.chat.getMessageStats() - Get raw statistics object
- window.chat.messageLog    - Access full message log array

üéØ Agent & Connection:
- window.chat.selectedAgent - Current selected agent
- window.chat.websocket     - WebSocket connection object
- window.chat.messageStats  - Live message statistics

üí° Examples:
  > debugChat()
  > chatStats()  
  > testWebSocket()
  > window.chat.printRecentMessages(5)
        `);
        return this.getMessageStats();
    }
}

// Initialize PolyMind Chat when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    window.chat = new PolyMindChat();
    
    // Global debug helpers - Generated by Copilot
    window.debugChat = () => {
        console.group('üß† PolyMind Chat Debug Info');
        console.log('Agent:', window.chat.selectedAgent);
        console.log('WebSocket State:', window.chat.websocket?.readyState);
        console.log('Connection URL:', window.chat.wsUrl);
        console.log('Reconnect Attempts:', window.chat.reconnectAttempts);
        console.log('Message Stats:', window.chat.getMessageStats());
        console.log('Recent Messages:', window.chat.messageLog.slice(-5));
        console.groupEnd();
        return window.chat.getMessageStats();
    };
    
    window.chatStats = () => {
        return window.chat.printStats();
    };
    
    window.testWebSocket = () => {
        if (!window.chat.websocket || window.chat.websocket.readyState !== WebSocket.OPEN) {
            console.warn('‚ö†Ô∏è WebSocket not connected');
            return false;
        }
        
        const testMessage = {
            content: 'Test message from debug console - ' + new Date().toISOString(),
            agent: window.chat.selectedAgent,
            timestamp: new Date().toISOString()
        };
        
        console.log('üß™ Sending test message via WebSocket:', testMessage);
        window.chat.websocket.send(JSON.stringify(testMessage));
        return true;
    };
    
    // Make PolyMindChat available globally for advanced debugging
    window.PolyMindChat = window.chat;
    
    console.log('üß† PolyMind Chat initialized with enhanced logging');
    console.log('üí° Type debugChat() for debug helpers');
    console.log('üìä Type chatStats() for statistics');
    console.log('üß™ Type testWebSocket() to test connection');
});