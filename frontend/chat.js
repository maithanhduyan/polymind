// Generated by Copilot

class PolyMindChat {
    constructor() {
        this.apiBaseUrl = window.location.origin;
        this.wsUrl = `ws://${window.location.host}/ws/chat`;
        this.messages = [];
        this.isTyping = false;
        this.selectedAgent = 'general';
        this.websocket = null;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 5;
        
        this.init();
    }

    init() {
        this.setupEventListeners();
        this.setupTextarea();
        this.updateWelcomeTime();
        this.setupAgentSelector();
        this.connectWebSocket();
        this.setupSidebar();
        
        console.log('üß† PolyMind Chat initialized with WebSocket and Sidebar');
    }    /**
     * Kh·ªüi t·∫°o WebSocket connection v·ªõi error handling c·∫£i ti·∫øn
     */
    connectWebSocket() {
        try {
            this.websocket = new WebSocket(this.wsUrl);
            
            this.websocket.onopen = () => {
                console.log('‚úÖ WebSocket connected');
                this.updateConnectionStatus('connected');
                this.reconnectAttempts = 0;
                
                // Th√™m animation cho status dot khi connected
                this.animateStatusDot('success');
            };

            this.websocket.onmessage = (event) => {
                const data = JSON.parse(event.data);
                this.handleWebSocketMessage(data);
            };

            this.websocket.onclose = () => {
                console.log('‚ùå WebSocket disconnected');
                this.updateConnectionStatus('disconnected');
                this.animateStatusDot('error');
                this.attemptReconnect();
            };

            this.websocket.onerror = (error) => {
                console.error('üö® WebSocket error:', error);
                this.updateConnectionStatus('disconnected');
                this.animateStatusDot('error');
            };

        } catch (error) {
            console.error('Failed to connect WebSocket:', error);
            this.updateConnectionStatus('disconnected');
            this.animateStatusDot('error');
        }
    }

    attemptReconnect() {
        if (this.reconnectAttempts < this.maxReconnectAttempts) {
            this.reconnectAttempts++;
            this.updateConnectionStatus('connecting');
            
            setTimeout(() => {
                console.log(`üîÑ Reconnect attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts}`);
                this.connectWebSocket();
            }, 2000 * this.reconnectAttempts);
        }
    }

    handleWebSocketMessage(data) {
        if (data.type === 'ai_response') {
            this.hideTyping();
            this.addMessage(data.content, 'ai');
        }
    }    /**
     * C·∫≠p nh·∫≠t tr·∫°ng th√°i k·∫øt n·ªëi v·ªõi UI c·∫£i ti·∫øn
     * @param {string} status - Tr·∫°ng th√°i k·∫øt n·ªëi ('connected', 'disconnected', 'connecting')
     */
    updateConnectionStatus(status) {
        const connectionStatus = document.getElementById('connectionStatus');
        const statusText = document.getElementById('statusText');
        
        if (!connectionStatus) return;
        
        connectionStatus.className = `connection-status ${status}`;
        
        // Map tr·∫°ng th√°i sang text ti·∫øng Vi·ªát
        const statusMessages = {
            'connected': 'ƒê√£ k·∫øt n·ªëi',
            'disconnected': 'M·∫•t k·∫øt n·ªëi',
            'connecting': 'ƒêang k·∫øt n·ªëi...'
        };
        
        const message = statusMessages[status] || 'Kh√¥ng x√°c ƒë·ªãnh';
        
        // C·∫≠p nh·∫≠t tooltip
        connectionStatus.setAttribute('data-status', message);
        
        // C·∫≠p nh·∫≠t text element n·∫øu c√≥
        if (statusText) {
            statusText.textContent = message;
        }
        
        // Log cho debugging
        console.log(`üîå Connection status: ${status} (${message})`);
    }

    setupEventListeners() {
        // Chat form submission
        const chatForm = document.getElementById('chatForm');
        chatForm.addEventListener('submit', (e) => {
            e.preventDefault();
            this.sendMessage();
        });

        // Textarea auto-resize and shortcuts
        const chatInput = document.getElementById('chatInput');
        chatInput.addEventListener('input', () => {
            this.updateCharCount();
            this.autoResizeTextarea();
            this.updateSendButton();
        });

        chatInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                this.sendMessage();
            }
        });

        // Send button
        const sendButton = document.getElementById('sendButton');
        sendButton.addEventListener('click', () => {
            this.sendMessage();
        });
    }

    setupTextarea() {
        const chatInput = document.getElementById('chatInput');
        chatInput.style.height = 'auto';
        this.updateSendButton();
    }

    setupAgentSelector() {
        const agentSelector = document.getElementById('agentSelector');
        agentSelector.addEventListener('change', (e) => {
            this.selectedAgent = e.target.value;
            this.addSystemMessage(`ƒê√£ chuy·ªÉn sang ${e.target.options[e.target.selectedIndex].text}`);
        });
    }

    updateWelcomeTime() {
        const welcomeTime = document.getElementById('welcomeTime');
        if (welcomeTime) {
            welcomeTime.textContent = new Date().toLocaleTimeString('vi-VN');
        }
    }

    updateCharCount() {
        const chatInput = document.getElementById('chatInput');
        const charCount = document.getElementById('charCount');
        const currentLength = chatInput.value.length;
        const maxLength = parseInt(chatInput.getAttribute('maxlength')) || 2000;
        
        charCount.textContent = `${currentLength}/${maxLength}`;
        
        // Change color if approaching limit
        if (currentLength > maxLength * 0.8) {
            charCount.style.color = 'var(--warning-color)';
        } else if (currentLength > maxLength * 0.9) {
            charCount.style.color = 'var(--error-color)';
        } else {
            charCount.style.color = 'var(--text-light)';
        }
    }

    autoResizeTextarea() {
        const chatInput = document.getElementById('chatInput');
        chatInput.style.height = 'auto';
        chatInput.style.height = Math.min(chatInput.scrollHeight, 120) + 'px';
    }

    updateSendButton() {
        const chatInput = document.getElementById('chatInput');
        const sendButton = document.getElementById('sendButton');
        const hasText = chatInput.value.trim().length > 0;
        
        sendButton.disabled = !hasText || this.isTyping;
    }    async sendMessage() {
        const chatInput = document.getElementById('chatInput');
        const message = chatInput.value.trim();
        
        if (!message || this.isTyping) return;

        // Check WebSocket connection
        if (!this.websocket || this.websocket.readyState !== WebSocket.OPEN) {
            this.addMessage('K·∫øt n·ªëi b·ªã gi√°n ƒëo·∫°n. ƒêang th·ª≠ k·∫øt n·ªëi l·∫°i...', 'ai', true);
            this.connectWebSocket();
            return;
        }

        // Add user message
        this.addMessage(message, 'user');
        
        // Clear input
        chatInput.value = '';
        this.updateCharCount();
        this.autoResizeTextarea();
        this.updateSendButton();

        // Show typing indicator
        this.showTyping();

        try {
            // Send message via WebSocket
            const messageData = {
                content: message,
                agent: this.selectedAgent,
                timestamp: new Date().toISOString()
            };
            
            this.websocket.send(JSON.stringify(messageData));
            
        } catch (error) {
            console.error('Error sending message:', error);
            this.hideTyping();
            this.addMessage('Xin l·ªói, ƒë√£ c√≥ l·ªói x·∫£y ra. Vui l√≤ng th·ª≠ l·∫°i.', 'ai', true);
        }
    }

    addMessage(content, sender, isError = false) {
        const chatMessages = document.getElementById('chatMessages');
        const messageDiv = document.createElement('div');
        const timestamp = new Date().toLocaleTimeString('vi-VN');
        const messageId = 'msg_' + Date.now();

        messageDiv.className = `message ${sender}`;
        messageDiv.id = messageId;

        const avatarContent = sender === 'user' ? 
            '<i class="fas fa-user"></i>' : 
            '<i class="fas fa-robot"></i>';

        const senderName = sender === 'user' ? 'B·∫°n' : 'AI Assistant';
        const messageClass = isError ? 'error-message' : '';

        messageDiv.innerHTML = `
            <div class="message-avatar">
                ${avatarContent}
            </div>
            <div class="message-bubble">
                <div class="message-content ${messageClass}">
                    ${this.formatMessage(content)}
                </div>
                <div class="message-time">${senderName} ‚Ä¢ ${timestamp}</div>
            </div>
        `;

        // Insert before typing indicator
        const typingIndicator = document.getElementById('typingIndicator');
        chatMessages.insertBefore(messageDiv, typingIndicator);

        // Animate message appearance
        messageDiv.style.opacity = '0';
        messageDiv.style.transform = 'translateY(20px)';
        
        setTimeout(() => {
            messageDiv.style.opacity = '1';
            messageDiv.style.transform = 'translateY(0)';
        }, 10);

        // Scroll to bottom
        this.scrollToBottom();

        // Store message
        this.messages.push({
            id: messageId,
            content,
            sender,
            timestamp: Date.now(),
            agent: this.selectedAgent
        });
    }

    addSystemMessage(content) {
        const chatMessages = document.getElementById('chatMessages');
        const messageDiv = document.createElement('div');
        
        messageDiv.innerHTML = `
            <div style="text-align: center; margin: var(--spacing-md) 0;">
                <div style="display: inline-block; background: var(--bg-primary); color: var(--text-secondary); padding: var(--spacing-xs) var(--spacing-md); border-radius: 20px; font-size: 0.875rem;">
                    <i class="fas fa-info-circle"></i> ${content}
                </div>
            </div>
        `;

        const typingIndicator = document.getElementById('typingIndicator');
        chatMessages.insertBefore(messageDiv, typingIndicator);
        this.scrollToBottom();
    }

    formatMessage(content) {
        // Basic message formatting
        return content
            .replace(/\n/g, '<br>')
            .replace(/`([^`]+)`/g, '<code>$1</code>')
            .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
            .replace(/\*([^*]+)\*/g, '<em>$1</em>');
    }

    showTyping() {
        this.isTyping = true;
        const typingIndicator = document.getElementById('typingIndicator');
        typingIndicator.style.display = 'flex';
        this.updateSendButton();
        this.scrollToBottom();
    }

    hideTyping() {
        this.isTyping = false;
        const typingIndicator = document.getElementById('typingIndicator');
        typingIndicator.style.display = 'none';
        this.updateSendButton();
    }

    async simulateAIResponse(userMessage) {
        // Simulate processing time
        await new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 2000));

        // Generate response based on agent type and user message
        const response = this.generateAIResponse(userMessage);
        this.addMessage(response, 'ai');
    }

    generateAIResponse(userMessage) {
        const responses = {
            general: [
                `C·∫£m ∆°n b·∫°n ƒë√£ h·ªèi "${userMessage}". T√¥i s·∫Ω gi√∫p b·∫°n t√¨m hi·ªÉu v·ªÅ v·∫•n ƒë·ªÅ n√†y.`,
                `ƒê√¢y l√† m·ªôt c√¢u h·ªèi th√∫ v·ªã v·ªÅ "${userMessage}". H√£y ƒë·ªÉ t√¥i ph√¢n t√≠ch v√† ƒë∆∞a ra c√¢u tr·∫£ l·ªùi chi ti·∫øt.`,
                `T√¥i hi·ªÉu b·∫°n mu·ªën bi·∫øt v·ªÅ "${userMessage}". ƒê√¢y l√† nh·ªØng th√¥ng tin h·ªØu √≠ch t√¥i c√≥ th·ªÉ chia s·∫ª.`
            ],
            coding: [
                `V·ªÅ v·∫•n ƒë·ªÅ l·∫≠p tr√¨nh "${userMessage}", t√¥i s·∫Ω gi√∫p b·∫°n v·ªõi code example v√† best practices.`,
                `ƒê√¢y l√† m·ªôt c√¢u h·ªèi technical hay v·ªÅ "${userMessage}". H√£y ƒë·ªÉ t√¥i gi·∫£i th√≠ch chi ti·∫øt.`,
                `T√¥i s·∫Ω h·ªó tr·ª£ b·∫°n v·ªõi "${userMessage}" b·∫±ng c√°ch ƒë∆∞a ra solution v√† gi·∫£i th√≠ch t·ª´ng b∆∞·ªõc.`
            ],
            analysis: [
                `T√¥i s·∫Ω ph√¢n t√≠ch d·ªØ li·ªáu v·ªÅ "${userMessage}" v√† ƒë∆∞a ra insights quan tr·ªçng.`,
                `V·ªÅ "${userMessage}", t√¥i s·∫Ω th·ª±c hi·ªán analysis chi ti·∫øt v√† ƒë∆∞a ra recommendations.`,
                `D·ª±a tr√™n "${userMessage}", t√¥i s·∫Ω cung c·∫•p data-driven insights v√† visualizations.`
            ],
            creative: [
                `T√¥i s·∫Ω s√°ng t·∫°o n·ªôi dung v·ªÅ "${userMessage}" v·ªõi style ƒë·ªôc ƒë√°o v√† engaging.`,
                `V·ªÅ ch·ªß ƒë·ªÅ "${userMessage}", t√¥i s·∫Ω vi·∫øt m·ªôt c√°ch creative v√† compelling.`,
                `H√£y ƒë·ªÉ t√¥i t·∫°o ra n·ªôi dung th√∫ v·ªã v·ªÅ "${userMessage}" v·ªõi g√≥c nh√¨n m·ªõi m·∫ª.`
            ]
        };

        const agentResponses = responses[this.selectedAgent] || responses.general;
        const randomResponse = agentResponses[Math.floor(Math.random() * agentResponses.length)];
        
        return randomResponse + '\n\nB·∫°n c√≥ mu·ªën t√¥i gi·∫£i th√≠ch th√™m chi ti·∫øt v·ªÅ v·∫•n ƒë·ªÅ n√†y kh√¥ng?';
    }

    scrollToBottom() {
        const chatMessages = document.getElementById('chatMessages');
        chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    clearChat() {
        const chatMessages = document.getElementById('chatMessages');
        const messages = chatMessages.querySelectorAll('.message');
        
        messages.forEach(message => {
            if (!message.classList.contains('ai') || message.querySelector('.message-content p')) {
                message.remove();
            }
        });

        this.messages = [];
        this.addSystemMessage('ƒê√£ x√≥a l·ªãch s·ª≠ chat');
    }

    /**
     * T·∫°o animation cho status dot
     * @param {string} type - Lo·∫°i animation ('success', 'error', 'warning')
     */
    animateStatusDot(type) {
        const statusDot = document.querySelector('.status-dot');
        if (!statusDot) return;
        
        // X√≥a animation c≈©
        statusDot.classList.remove('animate-success', 'animate-error', 'animate-warning');
        
        // Th√™m animation m·ªõi
        statusDot.classList.add(`animate-${type}`);
        
        // X√≥a class animation sau khi ho√†n th√†nh
        setTimeout(() => {
            statusDot.classList.remove(`animate-${type}`);
        }, 600);
    }

    /**
     * Toggle sidebar visibility tr√™n mobile
     */    toggleSidebar() {
        const sidebar = document.querySelector('.sidebar');
        const overlay = document.querySelector('.sidebar-overlay');
        
        if (!sidebar) return;
        
        sidebar.classList.toggle('open');
        
        // T·∫°o overlay n·∫øu ch∆∞a c√≥
        if (!overlay) {
            const newOverlay = document.createElement('div');
            newOverlay.className = 'sidebar-overlay';
            newOverlay.addEventListener('click', () => this.closeSidebar());
            document.body.appendChild(newOverlay);
        }
        
        // Toggle overlay
        const currentOverlay = document.querySelector('.sidebar-overlay');
        if (sidebar.classList.contains('open')) {
            currentOverlay?.classList.add('show');
            document.body.style.overflow = 'hidden'; // Prevent scroll
        } else {
            currentOverlay?.classList.remove('show');
            document.body.style.overflow = '';
        }
    }    /**
     * ƒê√≥ng sidebar
     */
    closeSidebar() {
        const sidebar = document.querySelector('.sidebar');
        const overlay = document.querySelector('.sidebar-overlay');
        
        sidebar?.classList.remove('open');
        overlay?.classList.remove('show');
        document.body.style.overflow = '';
    }

    /**
     * Setup sidebar event listeners
     */
    setupSidebar() {
        // Mobile menu toggle button
        const mobileMenuBtn = document.getElementById('mobileMenuBtn');
        if (mobileMenuBtn) {
            mobileMenuBtn.addEventListener('click', () => this.toggleSidebar());
        }        // Close sidebar when clicking outside on mobile
        document.addEventListener('click', (e) => {
            const sidebar = document.querySelector('.sidebar');
            const mobileMenuBtn = document.getElementById('mobileMenuBtn');
            
            if (window.innerWidth <= 768 && 
                sidebar?.classList.contains('open') &&
                !sidebar.contains(e.target) &&
                e.target !== mobileMenuBtn &&
                !mobileMenuBtn?.contains(e.target)) {
                this.closeSidebar();
            }
        });

        // Handle escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                this.closeSidebar();
            }
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            if (window.innerWidth > 768) {
                this.closeSidebar();
            }
        });

        // Setup chat history items
        this.setupChatHistory();
    }    /**
     * Setup chat history functionality
     */
    setupChatHistory() {
        const historyItems = document.querySelectorAll('.chat-item');
        historyItems.forEach(item => {
            // Click handler
            item.addEventListener('click', (e) => {
                this.handleChatItemSelection(e, item, historyItems);
            });
            
            // Keyboard handler for accessibility
            item.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    this.handleChatItemSelection(e, item, historyItems);
                }
            });
        });
    }

    /**
     * Handle chat item selection (click or keyboard)
     */
    handleChatItemSelection(e, item, historyItems) {
        e.preventDefault();
        
        // Remove active class from all items
        historyItems.forEach(i => i.classList.remove('active'));
        
        // Add active class to selected item
        item.classList.add('active');
        
        // Load chat history (placeholder)
        const chatId = item.dataset.chatId || item.querySelector('.chat-item-title')?.textContent || 'unknown';
        this.loadChatHistory(chatId);
        
        // Close sidebar on mobile after selection
        if (window.innerWidth <= 768) {
            this.closeSidebar();
        }
    }

    /**
     * Load chat history (placeholder)
     * @param {string} chatId - ID c·ªßa chat c·∫ßn load
     */
    loadChatHistory(chatId) {
        // TODO: Implement actual chat history loading
        console.log(`Loading chat history: ${chatId}`);
        this.addSystemMessage(`ƒê√£ chuy·ªÉn sang cu·ªôc tr√≤ chuy·ªán: ${chatId}`);
    }

    // ...existing code...
}

// Global functions for HTML onclick handlers
window.clearChat = function() {
    if (window.polymindChat) {
        if (confirm('B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a to√†n b·ªô l·ªãch s·ª≠ chat?')) {
            window.polymindChat.clearChat();
        }
    }
};

window.exportChat = function() {
    if (window.polymindChat) {
        window.polymindChat.exportChat();
    }
};

// Initialize chat when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    window.polymindChat = new PolyMindChat();
    
    // Add keyboard shortcuts
    document.addEventListener('keydown', (e) => {
        // Ctrl/Cmd + K to focus input
        if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
            e.preventDefault();
            document.getElementById('chatInput').focus();
        }
        
        // Escape to blur input
        if (e.key === 'Escape') {
            document.getElementById('chatInput').blur();
        }
    });
});

// Expose for debugging
window.PolyMindChat = {
    instance: null,
    version: '1.0.0',
    debug: () => window.polymindChat ? window.polymindChat.getDebugInfo() : null
};
