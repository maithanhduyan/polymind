// Generated by Copilot

class PolyMindChat {
    constructor() {
        this.apiBaseUrl = window.location.origin;
        this.wsUrl = `ws://${window.location.host}/ws/chat`;
        this.messages = [];
        this.isTyping = false;
        this.selectedAgent = 'general';
        this.websocket = null;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 5;
        
        this.init();
    }

    init() {
        this.setupEventListeners();
        this.setupTextarea();
        this.updateWelcomeTime();
        this.setupAgentSelector();
        this.connectWebSocket();
        
        console.log('üß† PolyMind Chat initialized with WebSocket');
    }

    connectWebSocket() {
        try {
            this.websocket = new WebSocket(this.wsUrl);
            
            this.websocket.onopen = () => {
                console.log('‚úÖ WebSocket connected');
                this.updateConnectionStatus('connected');
                this.reconnectAttempts = 0;
            };

            this.websocket.onmessage = (event) => {
                const data = JSON.parse(event.data);
                this.handleWebSocketMessage(data);
            };

            this.websocket.onclose = () => {
                console.log('‚ùå WebSocket disconnected');
                this.updateConnectionStatus('disconnected');
                this.attemptReconnect();
            };

            this.websocket.onerror = (error) => {
                console.error('üö® WebSocket error:', error);
                this.updateConnectionStatus('disconnected');
            };

        } catch (error) {
            console.error('Failed to connect WebSocket:', error);
            this.updateConnectionStatus('disconnected');
        }
    }

    attemptReconnect() {
        if (this.reconnectAttempts < this.maxReconnectAttempts) {
            this.reconnectAttempts++;
            this.updateConnectionStatus('connecting');
            
            setTimeout(() => {
                console.log(`üîÑ Reconnect attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts}`);
                this.connectWebSocket();
            }, 2000 * this.reconnectAttempts);
        }
    }

    handleWebSocketMessage(data) {
        if (data.type === 'ai_response') {
            this.hideTyping();
            this.addMessage(data.content, 'ai');
        }
    }

    updateConnectionStatus(status) {
        const connectionStatus = document.getElementById('connectionStatus');
        const statusText = document.getElementById('statusText');
        
        connectionStatus.className = `connection-status ${status}`;
        
        switch (status) {
            case 'connected':
                statusText.textContent = 'Connected';
                break;
            case 'disconnected':
                statusText.textContent = 'Disconnected';
                break;
            case 'connecting':
                statusText.textContent = 'Connecting...';
                break;
        }
    }

    setupEventListeners() {
        // Chat form submission
        const chatForm = document.getElementById('chatForm');
        chatForm.addEventListener('submit', (e) => {
            e.preventDefault();
            this.sendMessage();
        });

        // Textarea auto-resize and shortcuts
        const chatInput = document.getElementById('chatInput');
        chatInput.addEventListener('input', () => {
            this.updateCharCount();
            this.autoResizeTextarea();
            this.updateSendButton();
        });

        chatInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                this.sendMessage();
            }
        });

        // Send button
        const sendButton = document.getElementById('sendButton');
        sendButton.addEventListener('click', () => {
            this.sendMessage();
        });
    }

    setupTextarea() {
        const chatInput = document.getElementById('chatInput');
        chatInput.style.height = 'auto';
        this.updateSendButton();
    }

    setupAgentSelector() {
        const agentSelector = document.getElementById('agentSelector');
        agentSelector.addEventListener('change', (e) => {
            this.selectedAgent = e.target.value;
            this.addSystemMessage(`ƒê√£ chuy·ªÉn sang ${e.target.options[e.target.selectedIndex].text}`);
        });
    }

    updateWelcomeTime() {
        const welcomeTime = document.getElementById('welcomeTime');
        if (welcomeTime) {
            welcomeTime.textContent = new Date().toLocaleTimeString('vi-VN');
        }
    }

    updateCharCount() {
        const chatInput = document.getElementById('chatInput');
        const charCount = document.getElementById('charCount');
        const currentLength = chatInput.value.length;
        const maxLength = parseInt(chatInput.getAttribute('maxlength')) || 2000;
        
        charCount.textContent = `${currentLength}/${maxLength}`;
        
        // Change color if approaching limit
        if (currentLength > maxLength * 0.8) {
            charCount.style.color = 'var(--warning-color)';
        } else if (currentLength > maxLength * 0.9) {
            charCount.style.color = 'var(--error-color)';
        } else {
            charCount.style.color = 'var(--text-light)';
        }
    }

    autoResizeTextarea() {
        const chatInput = document.getElementById('chatInput');
        chatInput.style.height = 'auto';
        chatInput.style.height = Math.min(chatInput.scrollHeight, 120) + 'px';
    }

    updateSendButton() {
        const chatInput = document.getElementById('chatInput');
        const sendButton = document.getElementById('sendButton');
        const hasText = chatInput.value.trim().length > 0;
        
        sendButton.disabled = !hasText || this.isTyping;
    }    async sendMessage() {
        const chatInput = document.getElementById('chatInput');
        const message = chatInput.value.trim();
        
        if (!message || this.isTyping) return;

        // Check WebSocket connection
        if (!this.websocket || this.websocket.readyState !== WebSocket.OPEN) {
            this.addMessage('K·∫øt n·ªëi b·ªã gi√°n ƒëo·∫°n. ƒêang th·ª≠ k·∫øt n·ªëi l·∫°i...', 'ai', true);
            this.connectWebSocket();
            return;
        }

        // Add user message
        this.addMessage(message, 'user');
        
        // Clear input
        chatInput.value = '';
        this.updateCharCount();
        this.autoResizeTextarea();
        this.updateSendButton();

        // Show typing indicator
        this.showTyping();

        try {
            // Send message via WebSocket
            const messageData = {
                content: message,
                agent: this.selectedAgent,
                timestamp: new Date().toISOString()
            };
            
            this.websocket.send(JSON.stringify(messageData));
            
        } catch (error) {
            console.error('Error sending message:', error);
            this.hideTyping();
            this.addMessage('Xin l·ªói, ƒë√£ c√≥ l·ªói x·∫£y ra. Vui l√≤ng th·ª≠ l·∫°i.', 'ai', true);
        }
    }

    addMessage(content, sender, isError = false) {
        const chatMessages = document.getElementById('chatMessages');
        const messageDiv = document.createElement('div');
        const timestamp = new Date().toLocaleTimeString('vi-VN');
        const messageId = 'msg_' + Date.now();

        messageDiv.className = `message ${sender}`;
        messageDiv.id = messageId;

        const avatarContent = sender === 'user' ? 
            '<i class="fas fa-user"></i>' : 
            '<i class="fas fa-robot"></i>';

        const senderName = sender === 'user' ? 'B·∫°n' : 'AI Assistant';
        const messageClass = isError ? 'error-message' : '';

        messageDiv.innerHTML = `
            <div class="message-avatar">
                ${avatarContent}
            </div>
            <div class="message-bubble">
                <div class="message-content ${messageClass}">
                    ${this.formatMessage(content)}
                </div>
                <div class="message-time">${senderName} ‚Ä¢ ${timestamp}</div>
            </div>
        `;

        // Insert before typing indicator
        const typingIndicator = document.getElementById('typingIndicator');
        chatMessages.insertBefore(messageDiv, typingIndicator);

        // Animate message appearance
        messageDiv.style.opacity = '0';
        messageDiv.style.transform = 'translateY(20px)';
        
        setTimeout(() => {
            messageDiv.style.opacity = '1';
            messageDiv.style.transform = 'translateY(0)';
        }, 10);

        // Scroll to bottom
        this.scrollToBottom();

        // Store message
        this.messages.push({
            id: messageId,
            content,
            sender,
            timestamp: Date.now(),
            agent: this.selectedAgent
        });
    }

    addSystemMessage(content) {
        const chatMessages = document.getElementById('chatMessages');
        const messageDiv = document.createElement('div');
        
        messageDiv.innerHTML = `
            <div style="text-align: center; margin: var(--spacing-md) 0;">
                <div style="display: inline-block; background: var(--bg-primary); color: var(--text-secondary); padding: var(--spacing-xs) var(--spacing-md); border-radius: 20px; font-size: 0.875rem;">
                    <i class="fas fa-info-circle"></i> ${content}
                </div>
            </div>
        `;

        const typingIndicator = document.getElementById('typingIndicator');
        chatMessages.insertBefore(messageDiv, typingIndicator);
        this.scrollToBottom();
    }

    formatMessage(content) {
        // Basic message formatting
        return content
            .replace(/\n/g, '<br>')
            .replace(/`([^`]+)`/g, '<code>$1</code>')
            .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
            .replace(/\*([^*]+)\*/g, '<em>$1</em>');
    }

    showTyping() {
        this.isTyping = true;
        const typingIndicator = document.getElementById('typingIndicator');
        typingIndicator.style.display = 'flex';
        this.updateSendButton();
        this.scrollToBottom();
    }

    hideTyping() {
        this.isTyping = false;
        const typingIndicator = document.getElementById('typingIndicator');
        typingIndicator.style.display = 'none';
        this.updateSendButton();
    }

    async simulateAIResponse(userMessage) {
        // Simulate processing time
        await new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 2000));

        // Generate response based on agent type and user message
        const response = this.generateAIResponse(userMessage);
        this.addMessage(response, 'ai');
    }

    generateAIResponse(userMessage) {
        const responses = {
            general: [
                `C·∫£m ∆°n b·∫°n ƒë√£ h·ªèi "${userMessage}". T√¥i s·∫Ω gi√∫p b·∫°n t√¨m hi·ªÉu v·ªÅ v·∫•n ƒë·ªÅ n√†y.`,
                `ƒê√¢y l√† m·ªôt c√¢u h·ªèi th√∫ v·ªã v·ªÅ "${userMessage}". H√£y ƒë·ªÉ t√¥i ph√¢n t√≠ch v√† ƒë∆∞a ra c√¢u tr·∫£ l·ªùi chi ti·∫øt.`,
                `T√¥i hi·ªÉu b·∫°n mu·ªën bi·∫øt v·ªÅ "${userMessage}". ƒê√¢y l√† nh·ªØng th√¥ng tin h·ªØu √≠ch t√¥i c√≥ th·ªÉ chia s·∫ª.`
            ],
            coding: [
                `V·ªÅ v·∫•n ƒë·ªÅ l·∫≠p tr√¨nh "${userMessage}", t√¥i s·∫Ω gi√∫p b·∫°n v·ªõi code example v√† best practices.`,
                `ƒê√¢y l√† m·ªôt c√¢u h·ªèi technical hay v·ªÅ "${userMessage}". H√£y ƒë·ªÉ t√¥i gi·∫£i th√≠ch chi ti·∫øt.`,
                `T√¥i s·∫Ω h·ªó tr·ª£ b·∫°n v·ªõi "${userMessage}" b·∫±ng c√°ch ƒë∆∞a ra solution v√† gi·∫£i th√≠ch t·ª´ng b∆∞·ªõc.`
            ],
            analysis: [
                `T√¥i s·∫Ω ph√¢n t√≠ch d·ªØ li·ªáu v·ªÅ "${userMessage}" v√† ƒë∆∞a ra insights quan tr·ªçng.`,
                `V·ªÅ "${userMessage}", t√¥i s·∫Ω th·ª±c hi·ªán analysis chi ti·∫øt v√† ƒë∆∞a ra recommendations.`,
                `D·ª±a tr√™n "${userMessage}", t√¥i s·∫Ω cung c·∫•p data-driven insights v√† visualizations.`
            ],
            creative: [
                `T√¥i s·∫Ω s√°ng t·∫°o n·ªôi dung v·ªÅ "${userMessage}" v·ªõi style ƒë·ªôc ƒë√°o v√† engaging.`,
                `V·ªÅ ch·ªß ƒë·ªÅ "${userMessage}", t√¥i s·∫Ω vi·∫øt m·ªôt c√°ch creative v√† compelling.`,
                `H√£y ƒë·ªÉ t√¥i t·∫°o ra n·ªôi dung th√∫ v·ªã v·ªÅ "${userMessage}" v·ªõi g√≥c nh√¨n m·ªõi m·∫ª.`
            ]
        };

        const agentResponses = responses[this.selectedAgent] || responses.general;
        const randomResponse = agentResponses[Math.floor(Math.random() * agentResponses.length)];
        
        return randomResponse + '\n\nB·∫°n c√≥ mu·ªën t√¥i gi·∫£i th√≠ch th√™m chi ti·∫øt v·ªÅ v·∫•n ƒë·ªÅ n√†y kh√¥ng?';
    }

    scrollToBottom() {
        const chatMessages = document.getElementById('chatMessages');
        chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    clearChat() {
        const chatMessages = document.getElementById('chatMessages');
        const messages = chatMessages.querySelectorAll('.message');
        
        messages.forEach(message => {
            if (!message.classList.contains('ai') || message.querySelector('.message-content p')) {
                message.remove();
            }
        });

        this.messages = [];
        this.addSystemMessage('ƒê√£ x√≥a l·ªãch s·ª≠ chat');
    }

    // Utility methods
    exportChat() {
        const data = {
            messages: this.messages,
            timestamp: new Date().toISOString(),
            agent: this.selectedAgent
        };
        
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `polymind-chat-${Date.now()}.json`;
        a.click();
        URL.revokeObjectURL(url);
    }

    getDebugInfo() {
        return {
            messagesCount: this.messages.length,
            selectedAgent: this.selectedAgent,
            isTyping: this.isTyping,
            timestamp: new Date().toISOString()
        };
    }
}

// Global functions for HTML onclick handlers
window.clearChat = function() {
    if (window.polymindChat) {
        if (confirm('B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a to√†n b·ªô l·ªãch s·ª≠ chat?')) {
            window.polymindChat.clearChat();
        }
    }
};

window.exportChat = function() {
    if (window.polymindChat) {
        window.polymindChat.exportChat();
    }
};

// Initialize chat when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    window.polymindChat = new PolyMindChat();
    
    // Add keyboard shortcuts
    document.addEventListener('keydown', (e) => {
        // Ctrl/Cmd + K to focus input
        if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
            e.preventDefault();
            document.getElementById('chatInput').focus();
        }
        
        // Escape to blur input
        if (e.key === 'Escape') {
            document.getElementById('chatInput').blur();
        }
    });
});

// Expose for debugging
window.PolyMindChat = {
    instance: null,
    version: '1.0.0',
    debug: () => window.polymindChat ? window.polymindChat.getDebugInfo() : null
};
