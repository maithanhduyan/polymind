#!/usr/bin/env node
// Generated by Copilot

/**
 * MCP Multi-Service Server - Framework for hosting multiple AI assistant services
 * Supports both stdio and HTTP transports with service discovery
 */

import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
  Tool,
} from '@modelcontextprotocol/sdk/types.js';
import { createServer, IncomingMessage, ServerResponse } from 'http';
import { URL } from 'url';
import { Service, TimeService, CalculatorService, PostgreSQLService, EmbeddingService, ChromaDBService } from './services/index.js';

/**
 * Service Registry - Manages multiple services
 */
class ServiceRegistry {
  private services: Map<string, Service> = new Map();

  register(service: Service) {
    if (this.services.has(service.namespace)) {
      throw new Error(`Service namespace '${service.namespace}' already registered`);
    }
    this.services.set(service.namespace, service);
  }

  get(namespace: string): Service | undefined {
    return this.services.get(namespace);
  }

  getAll(): Service[] {
    return Array.from(this.services.values());
  }

  async listAllTools(): Promise<{ tools: Tool[] }> {
    const tools: Tool[] = [];
    for (const service of this.services.values()) {
      const { tools: serviceTools } = await service.listTools();
      tools.push(...serviceTools.map(tool => ({
        ...tool,
        name: `${service.namespace}.${tool.name}`
      })));
    }
    return { tools };
  }

  async callTool(fullName: string, args: any): Promise<any> {
    const [namespace, toolName] = fullName.split('.', 2);
    if (!namespace || !toolName) {
      throw new Error(`Invalid tool name format: ${fullName}. Expected 'namespace.toolName'`);
    }

    const service = this.services.get(namespace);
    if (!service) {
      throw new Error(`Service not found: ${namespace}`);
    }

    return service.callTool(toolName, args);
  }
}

/**
 * Multi-Service Server Core
 */
class MultiServiceServer {
  private server: Server;
  private serviceRegistry: ServiceRegistry;

  constructor() {
    this.server = new Server(
      {
        name: 'multi-service-server',
        version: '1.0.0',
      },
      {
        capabilities: {
          tools: {},
        },
      }
    );

    this.serviceRegistry = new ServiceRegistry();
    this.setupToolHandlers();
  }

  /**
   * Register a new service
   */
  registerService(service: Service) {
    this.serviceRegistry.register(service);
    console.log(`Registered service: ${service.name} (${service.namespace})`);
  }

  /**
   * Setup tool handlers
   */
  private setupToolHandlers(): void {
    // List available tools across all services
    this.server.setRequestHandler(ListToolsRequestSchema, async () => {
      return this.serviceRegistry.listAllTools();
    });

    // Handle tool calls with namespace prefix
    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
      const { name, arguments: args } = request.params;
      return this.serviceRegistry.callTool(name, args);
    });
  }

  /**
   * Start in stdio mode
   */
  async startStdio(): Promise<void> {
    const transport = new StdioServerTransport();
    await this.server.connect(transport);
    console.error('Multi-service server running on stdio');
  }

  /**
   * Start in HTTP mode
   */
  async startHttp(port: number = 3000): Promise<void> {
    const httpServer = createServer(async (req: IncomingMessage, res: ServerResponse) => {
      try {
        const url = new URL(req.url || '/', `http://${req.headers.host}`);
        const pathname = url.pathname;

        // Health check
        if (pathname === '/health') {
          res.writeHead(200);
          res.end('OK');
          return;
        }

        // Service discovery
        if (pathname === '/services') {
          const services = this.serviceRegistry.getAll().map(s => ({
            namespace: s.namespace,
            name: s.name,
            version: s.version,
            description: s.description
          }));

          res.writeHead(200, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify(services));
          return;
        }

        if (req.method !== 'POST') {
          res.writeHead(405);
          res.end('Method Not Allowed');
          return;
        }

        let body = '';
        for await (const chunk of req) {
          body += chunk;
        }

        const request = JSON.parse(body);
        let response: any;

        if (pathname === '/list-tools') {
          response = await this.serviceRegistry.listAllTools();
        }
        else if (pathname === '/call-tool') {
          if (!request.name || !request.arguments) {
            throw new Error('Invalid request format');
          }
          response = await this.serviceRegistry.callTool(request.name, request.arguments);
        }
        else if (pathname.startsWith('/service/')) {
          const [, , namespace, action] = pathname.split('/');
          const service = this.serviceRegistry.get(namespace);

          if (!service) {
            res.writeHead(404);
            res.end('Service not found');
            return;
          }

          if (action === 'list-tools') {
            response = await service.listTools();
          }
          else if (action === 'call-tool') {
            if (!request.name || !request.arguments) {
              throw new Error('Invalid request format');
            }
            response = await service.callTool(request.name, request.arguments);
          }
          else {
            res.writeHead(404);
            res.end('Not Found');
            return;
          }
        }
        else {
          res.writeHead(404);
          res.end('Not Found');
          return;
        }

        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify(response));
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        res.writeHead(400, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({
          error: 'Invalid request',
          message: errorMessage
        }));
      }
    });

    httpServer.listen(port, () => {
      console.error(`Multi-service server running on http://localhost:${port}`);
      console.error('Endpoints:');
      console.error('  GET  /health            - Health check');
      console.error('  GET  /services          - List registered services');
      console.error('  POST /list-tools        - List all tools across services');
      console.error('  POST /call-tool         - Execute a namespaced tool (e.g., "time.get_current_time")');
      console.error('  POST /service/:ns/list-tools - List tools for a specific service');
      console.error('  POST /service/:ns/call-tool  - Execute a tool in a specific service');
    });
  }
}

// Parse command-line arguments
const args = process.argv.slice(2);
const httpMode = args.includes('--http');
const portArgIndex = args.indexOf('--port');
const port = portArgIndex !== -1 ? parseInt(args[portArgIndex + 1]) : 3000;

// Create and configure server
const server = new MultiServiceServer();

// Register services
const embeddingService = new EmbeddingService();
server.registerService(new TimeService());
server.registerService(new CalculatorService());
server.registerService(new PostgreSQLService());
server.registerService(embeddingService);
server.registerService(new ChromaDBService(embeddingService));
// Add more services here...

// Start server
if (httpMode) {
  server.startHttp(port).catch((error) => {
    console.error('Failed to start HTTP server:', error);
    process.exit(1);
  });
} else {
  server.startStdio().catch((error) => {
    console.error('Failed to start stdio server:', error);
    process.exit(1);
  });
}