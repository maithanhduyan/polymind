# Generated by Copilot
"""
PolyMind Application Entry Point

Robust and safe entry point with comprehensive error handling and multiple startup modes.
"""

import os
import sys
import socket
import signal
from pathlib import Path
from typing import Optional
import logging

# Optional psutil import for advanced port management
try:
    import psutil

    PSUTIL_AVAILABLE = True
except ImportError:
    PSUTIL_AVAILABLE = False


# Configure logging
logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)


def check_port_available(host: str, port: int) -> bool:
    """Check if a port is available for binding."""
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
            sock.settimeout(1)
            result = sock.connect_ex((host, port))
            return result != 0
    except Exception:
        return False


def find_available_port(
    host: str, start_port: int, max_attempts: int = 10
) -> Optional[int]:
    """Find the next available port starting from start_port."""
    for port in range(start_port, start_port + max_attempts):
        if check_port_available(host, port):
            return port
    return None


def kill_processes_on_port(port: int) -> bool:
    """Kill processes using the specified port (requires psutil)."""
    if not PSUTIL_AVAILABLE:
        logger.warning("psutil not available. Cannot kill processes automatically.")
        logger.info(
            "Install psutil for automatic process management: pip install psutil"
        )
        return False

    try:
        killed = False
        for proc in psutil.process_iter(["pid", "name", "connections"]):
            try:
                connections = proc.info["connections"]
                if connections:
                    for conn in connections:
                        if (
                            hasattr(conn, "laddr")
                            and conn.laddr
                            and conn.laddr.port == port
                        ):
                            logger.warning(
                                f"Killing process {proc.info['pid']} ({proc.info['name']}) using port {port}"
                            )
                            proc.terminate()
                            killed = True
            except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
                pass
        return killed
    except Exception as e:
        logger.error(f"Error killing processes on port {port}: {e}")
        return False


def get_app():
    """Safely import and return the FastAPI app instance with robust error handling."""
    try:
        # Try relative import first (when running as module)
        from .app import app

        return app
    except ImportError:
        try:
            # Try absolute import (when running directly)
            sys.path.insert(0, str(Path(__file__).parent.parent))
            from backend.app import app

            return app
        except ImportError as e:
            logger.error(f"Failed to import app: {e}")
            logger.error("Make sure you're running from the project root directory")
            sys.exit(1)


def setup_signal_handlers():
    """Setup graceful shutdown signal handlers."""

    def signal_handler(signum, frame):
        logger.info(f"Received signal {signum}. Shutting down gracefully...")
        sys.exit(0)

    signal.signal(signal.SIGINT, signal_handler)
    if hasattr(signal, "SIGTERM"):
        signal.signal(signal.SIGTERM, signal_handler)


def validate_environment():
    """Validate the runtime environment."""
    # Check Python version
    if sys.version_info < (3, 8):
        logger.error("Python 3.8+ is required")
        sys.exit(1)

    # Check if we're in the correct directory
    current_dir = Path.cwd()
    expected_files = ["pyproject.toml", "backend"]

    if not all((current_dir / file).exists() for file in expected_files):
        logger.error("Please run from the project root directory")
        logger.error(f"Current directory: {current_dir}")
        sys.exit(1)


def main(
    host: str = "127.0.0.1",
    port: int = 8000,
    reload: bool = True,
    auto_kill: bool = False,
    auto_port: bool = False,
) -> None:
    """
    Safe entry point for running the PolyMind server with comprehensive error handling.

    Args:
        host: Host address to bind to
        port: Port number to listen on
        reload: Enable auto-reload on file changes
        auto_kill: Automatically kill processes using the port
        auto_port: Automatically find available port if specified port is busy
    """
    # Setup environment
    setup_signal_handlers()
    validate_environment()

    # Check port availability
    if not check_port_available(host, port):
        if auto_kill:
            logger.warning(f"Port {port} is busy. Attempting to kill processes...")
            if kill_processes_on_port(port):
                logger.info("Processes killed. Waiting a moment...")
                import time

                time.sleep(2)
            else:
                logger.error("Failed to kill processes on port")

        if auto_port:
            logger.warning(f"Port {port} is busy. Finding alternative port...")
            new_port = find_available_port(host, port + 1)
            if new_port:
                port = new_port
                logger.info(f"Using port {port} instead")
            else:
                logger.error("No available ports found")
                sys.exit(1)
        elif not check_port_available(host, port):
            logger.error(f"Port {port} is already in use!")
            logger.info("Solutions:")
            logger.info(f"  1. Use --auto-port to find available port")
            logger.info(f"  2. Use --auto-kill to kill existing processes")
            logger.info(f"  3. Use --port {port + 1} to try different port")
            sys.exit(1)

    # Import uvicorn
    try:
        import uvicorn
    except ImportError:
        logger.error(
            "uvicorn not found. Install it with: pip install uvicorn[standard]"
        )
        sys.exit(1)

    # Determine the correct module path
    if __name__ == "__main__":
        # Running directly: python backend/main.py
        app_module = "main:app"
        # Import app here for direct execution
        app = get_app()
        globals()["app"] = app
    else:
        # Running as module: python -m backend.main
        app_module = "backend.app:app"

    # Server configuration
    config = {
        "app": app_module,
        "host": host,
        "port": port,
        "log_level": "info",
        "access_log": True,
    }

    if reload:
        config.update(
            {
                "reload": True,
                "reload_dirs": ["backend", "frontend"],
                "reload_excludes": [
                    "*.pyc",
                    "__pycache__",
                    "*.log",
                    ".git",
                    ".vscode",
                    "logs",
                ],
            }
        )

    try:
        logger.info(f"🚀 Starting PolyMind server on {host}:{port}")
        logger.info(f"📝 Module: {app_module}")
        logger.info(f"🔄 Reload: {reload}")
        logger.info(f"📁 Working directory: {Path.cwd()}")

        uvicorn.run(**config)

    except KeyboardInterrupt:
        logger.info("🛑 Server stopped by user")
    except OSError as e:
        if "Address already in use" in str(e):
            logger.error(f"Port {port} is still in use after checks!")
            logger.info("This might be a race condition. Try again or use --auto-kill")
        else:
            logger.error(f"Server error: {e}")
        sys.exit(1)
    except Exception as e:
        logger.error(f"Unexpected error: {e}")
        import traceback

        logger.error(traceback.format_exc())
        sys.exit(1)


def dev_server() -> None:
    """Development server with hot reload and auto-recovery."""
    main(reload=True, auto_port=True)


def prod_server() -> None:
    """Production server without reload."""
    main(reload=False)


if __name__ == "__main__":
    # Parse command line arguments
    import argparse

    parser = argparse.ArgumentParser(
        description="PolyMind Server - Robust FastAPI Application"
    )
    parser.add_argument("--host", default="127.0.0.1", help="Host address to bind to")
    parser.add_argument(
        "--port", type=int, default=8000, help="Port number to listen on"
    )
    parser.add_argument("--no-reload", action="store_true", help="Disable auto-reload")
    parser.add_argument(
        "--prod", action="store_true", help="Production mode (no reload)"
    )
    parser.add_argument(
        "--auto-kill", action="store_true", help="Kill processes using the port"
    )
    parser.add_argument(
        "--auto-port", action="store_true", help="Find available port automatically"
    )

    args = parser.parse_args()

    reload = not (args.no_reload or args.prod)

    main(
        host=args.host,
        port=args.port,
        reload=reload,
        auto_kill=args.auto_kill,
        auto_port=args.auto_port,
    )


# For uvicorn auto-discovery
app = get_app()
