# Cấu trúc Dự án như sau:

```
..\polymind
├── frontend
│   ├── app.js
│   ├── chat.html
│   ├── chat.js
│   ├── index.html
│   └── styles.css
├── log_structure_report.py
├── logs
│   ├── polymind.log
│   └── polymind_backup_20250620_081200.log
├── pyproject.toml
├── src
│   ├── __init__.py
│   ├── adapters
│   │   └── .gitkeep
│   ├── agents
│   │   ├── __init__.py
│   │   ├── deepseek.py
│   │   └── manager.py
│   ├── config.py
│   ├── main.py
│   ├── routes
│   │   ├── api
│   │   ├── chat.py
│   │   └── dashboard.py
│   ├── services
│   │   └── health.py
│   └── utils
│       ├── __init__.py
│       ├── async_logger.py
│       └── logger.py
├── standardize_logging.py
└── uv.lock
```

# Danh sách chi tiết các file:

## File ..\polymind\log_structure_report.py:
```python
# Generated by Copilot
"""
PolyMind Log Structure Analysis and Standardization Report

PROBLEM IDENTIFIED:
The log file (logs/polymind.log) had inconsistent structure with mixed content:

1. TEST LOGS:
   - Format: 2025-06-20 02:54:55 [DEBUG] test_basic - Debug message
   - Components: test_basic, test_vietnamese, worker_1, worker_2, etc.
   - Source: Testing scripts and benchmark files

2. APPLICATION LOGS:
   - Format: 2025-06-20 02:56:52 [INFO] polymind_main - 📝 Logger initialized
   - Components: polymind_main
   - Source: FastAPI application main.py

3. ENCODING ISSUES:
   - Some logs appeared with corrupted encoding despite UTF-8 configuration
   - Mixed content made log analysis difficult

STANDARDIZATION SOLUTION:
"""

import asyncio
from pathlib import Path
from datetime import datetime

class LogStructureStandardizer:
    """
    Standardizes PolyMind logging structure for consistent format.
    """
    
    UNIFIED_FORMAT = "YYYY-MM-DD HH:MM:SS [LEVEL] component - message"
    
    STANDARD_COMPONENTS = {
        "polymind_main": "Main application lifecycle",
        "polymind_websocket": "WebSocket connections and messages", 
        "polymind_agent": "AI agent operations",
        "polymind_api": "REST API endpoints",
        "polymind_config": "Configuration and environment",
        "polymind_error": "Error handling and exceptions"
    }
    
    @classmethod
    def get_recommendations(cls) -> dict:
        """Get recommendations for unified logging structure."""
        return {
            "format": cls.UNIFIED_FORMAT,
            "components": cls.STANDARD_COMPONENTS,
            "guidelines": [
                "Use emojis for visual clarity: 🚀 startup, 🔌 websocket, ❌ errors",
                "Vietnamese text fully supported with UTF-8 encoding",
                "Separate test logs from application logs", 
                "Use component-based logger names (not random test names)",
                "Maintain consistent message structure across modules",
                "Clean log file before production deployment"
            ],
            "examples": [
                "2025-06-20 15:30:45 [INFO] polymind_main - 🚀 PolyMind application starting...",
                "2025-06-20 15:30:46 [INFO] polymind_agent - 🤖 DeepSeek agent initialized",
                "2025-06-20 15:30:47 [INFO] polymind_websocket - 🔌 WebSocket server ready on port 8000",
                "2025-06-20 15:30:48 [INFO] polymind_main - 🇻🇳 Chào mừng đến với PolyMind!",
                "2025-06-20 15:30:49 [ERROR] polymind_error - ❌ Database connection failed"
            ]
        }
    
    @classmethod  
    def generate_clean_log_header(cls) -> str:
        """Generate clean header for log file."""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        return f"""# PolyMind Application Log - Unified Structure
# Generated: {timestamp}
# Format: {cls.UNIFIED_FORMAT}
#
# Standard Components:
{chr(10).join(f"# - {comp}: {desc}" for comp, desc in cls.STANDARD_COMPONENTS.items())}
#
# Guidelines:
# - Use emojis for visual clarity and quick scanning
# - Vietnamese text fully supported
# - Component-based logger names only
# - Consistent message structure
#
"""

def main():
    """Generate standardization report."""
    standardizer = LogStructureStandardizer()
    recommendations = standardizer.get_recommendations()
    
    print("🎯 PolyMind Log Structure Standardization Report")
    print("=" * 60)
    
    print(f"\n📋 UNIFIED FORMAT:")
    print(f"   {recommendations['format']}")
    
    print(f"\n🏗️ STANDARD COMPONENTS:")
    for comp, desc in recommendations['components'].items():
        print(f"   • {comp}: {desc}")
    
    print(f"\n✅ GUIDELINES:")
    for guideline in recommendations['guidelines']:
        print(f"   • {guideline}")
    
    print(f"\n📝 EXAMPLES:")
    for example in recommendations['examples']:
        print(f"   {example}")
    
    # Generate clean log file
    log_file = Path("logs/polymind.log")
    if log_file.exists():
        # Backup existing log
        backup_file = Path(f"logs/polymind_backup_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log")
        log_file.rename(backup_file)
        print(f"\n📦 Existing log backed up to: {backup_file}")
    
    # Create clean log file
    log_file.parent.mkdir(exist_ok=True)
    with open(log_file, 'w', encoding='utf-8') as f:
        f.write(standardizer.generate_clean_log_header())
    
    print(f"✨ Clean log file created: {log_file}")
    print(f"\n🎯 NEXT STEPS:")
    print("   1. Use only standard component names in logger calls")
    print("   2. Update main.py to use polymind_* component names")
    print("   3. Separate test logs from application logs")
    print("   4. Remove benchmark and test files from workspace")
    print("   5. Restart application to begin unified logging")

if __name__ == "__main__":
    main()

```

## File ..\polymind\standardize_logging.py:
```python
#!/usr/bin/env python3
"""
Log Structure Standardization Script

This script ensures consistent logging format across the PolyMind application.
Standardizes all logs to follow: YYYY-MM-DD HH:MM:SS [LEVEL] component - message

Key improvements:
1. Consistent logger names (no random test names)
2. Structured message format
3. Component-based logging (main, websocket, agent, etc.)
4. Vietnamese text support maintained
5. Emojis used consistently for visual clarity
"""

import asyncio
import logging
from datetime import datetime
from pathlib import Path
from src.utils.logger import get_logger

async def demonstrate_unified_logging():
    """Demonstrate the unified logging structure for PolyMind."""
    
    # Initialize loggers for different components
    main_logger = await get_logger("polymind_main")
    websocket_logger = await get_logger("polymind_websocket") 
    agent_logger = await get_logger("polymind_agent")
    api_logger = await get_logger("polymind_api")
    
    print("🔧 Demonstrating unified logging structure...")
    print("📁 Log file: logs/polymind.log")
    print("📋 Format: YYYY-MM-DD HH:MM:SS [LEVEL] component - message\n")
      # Application startup logs
    await main_logger.info("🚀 PolyMind application starting...")
    await main_logger.info("⚙️ Configuration loaded successfully")
    await main_logger.info("✅ Environment variables validated")
    
    # Agent logs  
    await agent_logger.info("🤖 DeepSeek agent initializing...")
    await agent_logger.info("✅ DeepSeek agent registered successfully")
    await agent_logger.info("🧠 Agent ready for conversations")
    
    # WebSocket logs
    await websocket_logger.info("🔌 WebSocket server started on port 8000")
    await websocket_logger.info("🔗 Client connected from 127.0.0.1")
    await websocket_logger.info("💬 Message received: Hello PolyMind!")
    await websocket_logger.info("📤 Response sent to client")
    await websocket_logger.info("❌ Client disconnected")
    
    # API logs
    await api_logger.info("🌐 REST API endpoints registered")
    await api_logger.info("📡 GET /health - Health check requested")
    await api_logger.info("📊 POST /chat - New chat session created")
    
    # Vietnamese content logs
    await main_logger.info("🇻🇳 Chào mừng đến với PolyMind!")
    await main_logger.info("📝 Xử lý thành công tin nhắn tiếng Việt")
    await main_logger.warning("⚠️ Cảnh báo: Tỷ lệ sử dụng CPU cao")
    
    # Error handling logs
    try:
        raise ValueError("Simulated error for demonstration")
    except Exception as e:
        await main_logger.error(f"❌ Application error: {str(e)}")
        await main_logger.error("🔧 Error handling activated")
    
    # Performance and monitoring logs
    await main_logger.info("📊 Processing 1,000 messages/second")
    await main_logger.info("💾 Memory usage: 250MB")
    await main_logger.info("⏱️ Average response time: 120ms")
    
    # Shutdown logs
    await websocket_logger.info("🔌 WebSocket connections closed")
    await agent_logger.info("🤖 Agent cleanup completed")
    await main_logger.info("🛑 PolyMind application shutdown complete")
    
    print("✅ Unified logging demonstration completed!")
    print("📄 Check logs/polymind.log for structured output")

async def validate_log_structure():
    """Validate that logs follow the unified structure."""
    
    log_file = Path("logs/polymind.log")
    if not log_file.exists():
        print("❌ Log file not found!")
        return False
    
    print("\n🔍 Validating log structure...")
    
    valid_components = {
        'polymind_main', 'polymind_websocket', 
        'polymind_agent', 'polymind_api'
    }
    
    issues_found = []
    
    with open(log_file, 'r', encoding='utf-8') as f:
        lines = f.readlines()
    
    for i, line in enumerate(lines, 1):
        line = line.strip()
        if line.startswith('#') or not line:
            continue
            
        # Check format: YYYY-MM-DD HH:MM:SS [LEVEL] component - message
        parts = line.split(' - ', 1)
        if len(parts) != 2:
            issues_found.append(f"Line {i}: Missing ' - ' separator")
            continue
            
        timestamp_level_component = parts[0]
        message = parts[1]
        
        # Extract component from the line
        try:
            component_part = timestamp_level_component.split('] ')[1]
            if component_part not in valid_components:
                issues_found.append(f"Line {i}: Invalid component '{component_part}'")
        except IndexError:
            issues_found.append(f"Line {i}: Invalid format")
    
    if issues_found:
        print(f"⚠️ Found {len(issues_found)} issues:")
        for issue in issues_found[:5]:  # Show first 5 issues
            print(f"  • {issue}")
        if len(issues_found) > 5:
            print(f"  • ... and {len(issues_found) - 5} more")
        return False
    else:
        print("✅ All logs follow unified structure!")
        return True

if __name__ == "__main__":
    print("🎯 PolyMind Log Structure Standardization")
    print("=" * 50)
    
    # Run the demonstration
    asyncio.run(demonstrate_unified_logging())
    
    # Validate the structure
    asyncio.run(validate_log_structure())
    
    print("\n📋 Logging Standards Summary:")
    print("• Format: YYYY-MM-DD HH:MM:SS [LEVEL] component - message")
    print("• Components: polymind_main, polymind_websocket, polymind_agent, polymind_api")
    print("• Emojis: Used for visual clarity and quick scanning")
    print("• Vietnamese: Full UTF-8 support maintained")
    print("• Structure: Consistent across all application modules")

```

## File ..\polymind\src\config.py:
```python
# Generated by Copilot
"""
Configuration management for PolyMind project.
"""

import os
from typing import Optional


class Config:
    """Application configuration."""
    
    # Together.xyz API configuration
    TOGETHER_API_KEY: Optional[str] = os.getenv("TOGETHER_API_KEY")
    TOGETHER_BASE_URL: str = "https://api.together.xyz/v1"
    
    # DeepSeek model configuration
    DEEPSEEK_MODEL: str = "deepseek-ai/DeepSeek-V3"
    DEEPSEEK_MAX_TOKENS: int = 4000
    DEEPSEEK_TEMPERATURE: float = 0.7
    
    # Application settings
    DEBUG: bool = os.getenv("DEBUG", "false").lower() == "true"
    HOST: str = os.getenv("HOST", "127.0.0.1")
    PORT: int = int(os.getenv("PORT", "8000"))
    
    @classmethod
    def check_required_env(cls) -> bool:
        """Kiểm tra các environment variables bắt buộc."""
        if not cls.TOGETHER_API_KEY:
            print("❌ TOGETHER_API_KEY environment variable is not set")
            print("💡 Please set your Together.xyz API key:")
            print("   export TOGETHER_API_KEY=your_api_key_here")
            return False
        return True


# Global config instance
config = Config()
```

## File ..\polymind\src\main.py:
```python
from fastapi import FastAPI, WebSocket, WebSocketDisconnect
from fastapi.staticfiles import StaticFiles
from fastapi.responses import FileResponse
from pathlib import Path
import json
import asyncio
from datetime import datetime
from src.services.health import router as health_router
from src.agents.manager import agent_manager
from src.agents import AgentType, AgentResponse
from src.config import config
from src.utils.logger import get_logger

app = FastAPI(title="PolyMind App", description="Fast modern AI service framework")

# Initialize logger
logger = None

async def get_app_logger():
    """Get or initialize global logger for the application."""
    global logger
    if logger is None:
        logger = await get_logger("polymind_main")
        await logger.info("📝 Logger initialized for PolyMind main application")
    return logger

@app.on_event("startup")
async def startup_event():
    """Setup agents khi khởi động app."""
    # Initialize logger first
    app_logger = await get_app_logger()
    
    await app_logger.info("🚀 Starting PolyMind application...")
    
    # Kiểm tra environment variables
    if not config.check_required_env():
        await app_logger.warning("⚠️  Some environment variables are missing. Some features may not work.")
        print("⚠️  Some environment variables are missing. Some features may not work.")
    else:
        await app_logger.info("✅ All required environment variables found")
    
    await agent_manager.setup_default_agents()
    await app_logger.info("✅ Agent setup completed")
    print("✅ Agent setup completed")

# WebSocket connection manager
class ConnectionManager:
    def __init__(self):
        self.active_connections: list[WebSocket] = []

    async def connect(self, websocket: WebSocket):
        await websocket.accept()
        self.active_connections.append(websocket)
        # Log connection
        if logger:
            await logger.info(f"🔌 New WebSocket connection established. Total connections: {len(self.active_connections)}")

    def disconnect(self, websocket: WebSocket):
        self.active_connections.remove(websocket)
        # Log disconnection (using sync logging for simplicity in sync method)
        if logger:
            import asyncio
            try:
                loop = asyncio.get_event_loop()
                loop.create_task(logger.info(f"🔌 WebSocket connection closed. Remaining connections: {len(self.active_connections)}"))
            except:
                pass  # Failsafe if no event loop

    async def send_personal_message(self, message: str, websocket: WebSocket):
        await websocket.send_text(message)

    async def broadcast(self, message: str):
        for connection in self.active_connections:
            await connection.send_text(message)

manager = ConnectionManager()

# Mount static files
app.mount("/static", StaticFiles(directory="frontend"), name="static")

# Include API routers
app.include_router(health_router)


# Serve frontend at root
@app.get("/")
async def serve_frontend():
    """Serve the main frontend page."""
    return FileResponse("frontend/index.html")


@app.get("/chat")
async def serve_chat():
    """Serve the main chat page."""
    return FileResponse("frontend/chat.html")


@app.get("/api")
async def api_root():
    """API root endpoint."""
    return {"status": "ok", "message": "PolyMind API is running"}


@app.get("/api/chat/agents")
async def get_chat_agents():
    """Get available chat agents."""
    agents = []
    for agent_id, agent_instance in agent_manager.agents.items():
        agent_info = agent_instance.info
        agents.append({
            "id": agent_id,
            "name": agent_info["name"],
            "description": agent_info["description"],
            "type": agent_info["type"],
            "conversation_length": agent_info.get("conversation_length", 0)
        })
    
    return {"agents": agents}


@app.get("/api/chat/agents/health")
async def get_agents_health():
    """Kiểm tra health của tất cả agents."""
    return await agent_manager.health_check()


# WebSocket endpoint for chat
@app.websocket("/ws/chat")
async def websocket_endpoint(websocket: WebSocket):
    await manager.connect(websocket)
    app_logger = await get_app_logger()
    
    try:
        while True:
            data = await websocket.receive_text()
            message_data = json.loads(data)
            
            # Lấy thông tin từ message
            user_message = message_data.get('content', '')
            agent_id = message_data.get('agent', 'deepseek')  # Default to deepseek
            is_streaming = message_data.get('streaming', False)
            
            # Log incoming message
            await app_logger.info(f"💬 Received message for agent '{agent_id}' (streaming: {is_streaming}): {user_message[:100]}{'...' if len(user_message) > 100 else ''}")
            
            try:
                if is_streaming:
                    # Streaming response
                    await manager.send_personal_message(json.dumps({
                        "type": "ai_typing",
                        "agent": agent_id
                    }), websocket)
                    
                    agent = agent_manager.get_agent(agent_id)
                    if agent:
                        response_content = ""
                        stream = await agent.stream_chat(user_message)
                        async for chunk in stream:
                            response_content += chunk
                            await manager.send_personal_message(json.dumps({
                                "type": "ai_chunk",
                                "content": chunk,
                                "agent": agent_id
                            }), websocket)
                          # Gửi final response
                        await manager.send_personal_message(json.dumps({
                            "type": "ai_response",
                            "content": response_content,
                            "timestamp": datetime.now().isoformat(),
                            "agent": agent_id                        
                        }), websocket)
                        
                        # Log successful streaming response
                        await app_logger.info(f"✅ Streaming response completed for agent '{agent_id}' - {len(response_content)} characters")
                    else:
                        await app_logger.error(f"❌ Agent '{agent_id}' không khả dụng")
                        await manager.send_personal_message(json.dumps({
                            "type": "error",
                            "content": f"Agent '{agent_id}' không khả dụng",
                            "timestamp": datetime.now().isoformat()
                        }), websocket)
                else:
                    # Regular response
                    response = await agent_manager.chat(user_message, agent_id)
                    
                    await manager.send_personal_message(json.dumps({
                        "type": "ai_response",
                        "content": response.content,
                        "timestamp": datetime.now().isoformat(),
                        "agent": agent_id,
                        "model": response.model_name
                    }), websocket)
                      # Log successful regular response
                    await app_logger.info(f"✅ Regular response completed for agent '{agent_id}' using model '{response.model_name}' - {len(response.content)} characters")
                    
            except Exception as e:
                # Log error details
                await app_logger.error(f"❌ Error processing message for agent '{agent_id}': {str(e)}")
                # Gửi error response
                await manager.send_personal_message(json.dumps({
                    "type": "error",
                    "content": f"Lỗi xử lý: {str(e)}",
                    "timestamp": datetime.now().isoformat()
                }), websocket)
            
    except WebSocketDisconnect:
        await app_logger.info("🔌 WebSocket client disconnected")
        manager.disconnect(websocket)
    except Exception as e:
        await app_logger.error(f"❌ WebSocket error: {str(e)}")
        manager.disconnect(websocket)


def main() -> None:
    """Entry point để chạy development server."""
    import uvicorn

    uvicorn.run("src.main:app", host="127.0.0.1", port=8000, reload=True)


if __name__ == "__main__":
    main()

```

## File ..\polymind\src\__init__.py:
```python
# Generated by Copilot
"""
PolyMind
Fast, modern AI service framework for vector database operations.
"""

__version__ = "0.1.0"
__author__ = "Mai Thành Duy An"
__email__ = "tiachop0102@gmail.com"

# Import các module chính để dễ dàng import từ package
from .main import app
# from .config import settings

# Public API - những gì có thể import từ bên ngoài
__all__ = [
    "app",
    "__version__",
]
```

## File ..\polymind\src\agents\deepseek.py:
```python
# Generated by Copilot
"""
DeepSeek V3 Agent Integration for PolyMind

Triển khai agent sử dụng DeepSeek V3 model thông qua Together.xyz API.
"""

import os
import asyncio
import httpx
import json
from typing import Dict, List, Optional, Any, AsyncGenerator
from dataclasses import dataclass

from . import BaseAgent, AgentType, AgentResponse, MessageRole
from ..config import config


@dataclass
class DeepSeekConfig:
    """Cấu hình cho DeepSeek agent."""
    api_key: str
    base_url: str = "https://api.together.xyz/v1"
    model: str = "deepseek-ai/DeepSeek-V3"
    max_tokens: int = 2048
    temperature: float = 0.7
    timeout: int = 30


class DeepSeekAgent(BaseAgent):
    """
    DeepSeek V3 Agent sử dụng Together.xyz API.
    
    Agent này cung cấp khả năng:
    - Reasoning mạnh mẽ
    - Code generation và debugging
    - Phân tích và giải quyết vấn đề
    - Hỗ trợ tiếng Việt
    """
    
    def __init__(self, config: DeepSeekConfig):
        super().__init__(
            agent_type=AgentType.DEEPSEEK,
            name="DeepSeek V3",
            description="AI Agent with advanced reasoning capabilities powered by DeepSeek V3"
        )
        
        self.config = config
        self.client = httpx.AsyncClient(
            base_url=config.base_url,
            timeout=config.timeout,
            headers={
                "Authorization": f"Bearer {config.api_key}",
                "Content-Type": "application/json"
            }
        )
    
    async def chat(self, message: str, **kwargs) -> AgentResponse:
        """
        Gửi tin nhắn đến DeepSeek V3 và nhận response.
        
        Args:
            message: Tin nhắn từ user
            **kwargs: Tham số bổ sung (temperature, max_tokens, etc.)
            
        Returns:
            AgentResponse với phản hồi từ DeepSeek V3
        """
        try:
            # Thêm tin nhắn user vào conversation
            self.add_message(MessageRole.USER, message)
            
            # Chuẩn bị messages cho API
            messages = self._prepare_messages()
            
            # Gọi API
            response = await self._make_api_call(messages, **kwargs)
            
            # Parse response
            assistant_message = response["choices"][0]["message"]["content"]
            usage = response.get("usage", {})
            
            # Thêm response vào conversation
            self.add_message(MessageRole.ASSISTANT, assistant_message)
            
            return AgentResponse(
                content=assistant_message,
                agent_type=self.agent_type,
                model_name=self.config.model,
                usage=usage,
                metadata={"response_id": response.get("id")}
            )
            
        except Exception as e:
            error_msg = f"Lỗi khi gọi DeepSeek API: {str(e)}"
            return AgentResponse(
                content=error_msg,
                agent_type=self.agent_type,
                model_name=self.config.model,
                metadata={"error": True, "error_type": type(e).__name__}
            )
    
    async def stream_chat(self, message: str, **kwargs) -> AsyncGenerator[str, None]:
        """
        Stream response từ DeepSeek V3.
        
        Args:
            message: Tin nhắn từ user
            **kwargs: Tham số bổ sung
            
        Yields:
            Từng phần của response
        """
        try:
            # Thêm tin nhắn user vào conversation
            self.add_message(MessageRole.USER, message)
            
            # Chuẩn bị messages cho API
            messages = self._prepare_messages()
            
            # Stream API call
            full_response = ""
            async for chunk in self._stream_api_call(messages, **kwargs):
                if chunk:
                    full_response += chunk
                    yield chunk
            
            # Thêm full response vào conversation
            if full_response:
                self.add_message(MessageRole.ASSISTANT, full_response)
                
        except Exception as e:
            yield f"Lỗi khi stream từ DeepSeek API: {str(e)}"
    
    def _prepare_messages(self) -> List[Dict[str, str]]:
        """Chuẩn bị messages cho API call."""
        messages = [{"role": "system", "content": self._get_enhanced_system_prompt()}]
        
        # Thêm conversation context
        conversation_messages = self.get_conversation_context(max_messages=20)
        messages.extend(conversation_messages)
        
        return messages
    
    def _get_enhanced_system_prompt(self) -> str:
        """System prompt được tối ưu cho DeepSeek V3."""
        return """Bạn là DeepSeek V3, một AI assistant thông minh với khả năng reasoning mạnh mẽ.

Đặc điểm của bạn:
- Suy luận logic và phân tích sâu sắc
- Hỗ trợ lập trình và debugging xuất sắc  
- Giải thích rõ ràng, dễ hiểu
- Hỗ trợ tiếng Việt tự nhiên
- Cung cấp examples và code khi cần thiết

Hãy trả lời một cách chi tiết, logic và hữu ích. Sử dụng markdown formatting khi phù hợp."""
    
    async def _make_api_call(self, messages: List[Dict], **kwargs) -> Dict[str, Any]:
        """Thực hiện API call đến Together.xyz."""
        payload = {
            "model": self.config.model,
            "messages": messages,
            "max_tokens": kwargs.get("max_tokens", self.config.max_tokens),
            "temperature": kwargs.get("temperature", self.config.temperature),
            "stream": False
        }
        
        response = await self.client.post("/chat/completions", json=payload)
        response.raise_for_status()
        return response.json()
    
    async def _stream_api_call(self, messages: List[Dict], **kwargs) -> AsyncGenerator[str, None]:
        """Stream API call đến Together.xyz."""
        payload = {
            "model": self.config.model,
            "messages": messages,
            "max_tokens": kwargs.get("max_tokens", self.config.max_tokens),
            "temperature": kwargs.get("temperature", self.config.temperature),
            "stream": True
        }
        
        async with self.client.stream("POST", "/chat/completions", json=payload) as response:
            response.raise_for_status()
            
            async for line in response.aiter_lines():
                if line.startswith("data: "):
                    data = line[6:]  # Remove "data: " prefix
                    
                    if data == "[DONE]":
                        break
                    
                    try:
                        json_data = json.loads(data)
                        delta = json_data["choices"][0]["delta"]
                        
                        if "content" in delta:
                            yield delta["content"]
                            
                    except (json.JSONDecodeError, KeyError, IndexError):
                        continue
    
    async def analyze_code(self, code: str, language: str = "python") -> AgentResponse:
        """
        Phân tích code và đưa ra suggestions.
        
        Args:
            code: Source code cần phân tích
            language: Ngôn ngữ lập trình
            
        Returns:
            AgentResponse với phân tích code
        """
        prompt = f"""Hãy phân tích đoạn code {language} sau và đưa ra feedback:

```{language}
{code}
```

Vui lòng phân tích:
1. Code quality và best practices
2. Potential bugs hoặc issues
3. Performance optimization suggestions
4. Security considerations (nếu có)
5. Suggestions for improvement

Trả lời bằng tiếng Việt và sử dụng markdown formatting."""
        
        return await self.chat(prompt)
    
    async def explain_concept(self, concept: str, level: str = "intermediate") -> AgentResponse:
        """
        Giải thích concept một cách chi tiết.
        
        Args:
            concept: Khái niệm cần giải thích
            level: Mức độ (beginner, intermediate, advanced)
            
        Returns:
            AgentResponse với giải thích
        """
        prompt = f"""Hãy giải thích khái niệm "{concept}" ở mức độ {level}.

Vui lòng bao gồm:
1. Định nghĩa rõ ràng
2. Tại sao concept này quan trọng
3. Examples thực tế
4. Use cases phổ biến
5. Related concepts

Trả lời bằng tiếng Việt, dễ hiểu và có structure rõ ràng."""
        
        return await self.chat(prompt)
    
    async def solve_problem(self, problem: str, context: str = "") -> AgentResponse:
        """
        Giải quyết vấn đề với reasoning step-by-step.
        
        Args:
            problem: Vấn đề cần giải quyết
            context: Context bổ sung
            
        Returns:
            AgentResponse với solution
        """
        prompt = f"""Vấn đề: {problem}

{f"Context: {context}" if context else ""}

Hãy giải quyết vấn đề này với approach step-by-step:
1. Phân tích vấn đề
2. Identify key factors
3. Brainstorm solutions
4. Evaluate options
5. Recommend best solution
6. Implementation steps

Sử dụng reasoning logic và trả lời bằng tiếng Việt."""
        
        return await self.chat(prompt)
    
    async def close(self):
        """Đóng connection."""
        await self.client.aclose()
    
    @property
    def info(self) -> Dict[str, Any]:
        """Thông tin chi tiết về DeepSeek agent."""
        base_info = super().info
        base_info.update({
            "model": self.config.model,
            "provider": "Together.xyz",
            "max_tokens": self.config.max_tokens,
            "temperature": self.config.temperature,
            "capabilities": [
                "Advanced reasoning",
                "Code analysis",
                "Problem solving", 
                "Vietnamese support",
                "Streaming responses"
            ]
        })
        return base_info


def create_deepseek_agent(api_key: Optional[str] = None) -> DeepSeekAgent:
    """
    Factory function để tạo DeepSeek agent.
    
    Args:
        api_key: Together.xyz API key (nếu None sẽ lấy từ config)
        
    Returns:
        DeepSeekAgent instance
    """
    if api_key is None:
        api_key = config.TOGETHER_API_KEY
        
    if not api_key:
        raise ValueError("TOGETHER_API_KEY environment variable hoặc api_key parameter là required")
    
    deepseek_config = DeepSeekConfig(
        api_key=api_key,
        base_url=config.TOGETHER_BASE_URL,
        model=config.DEEPSEEK_MODEL,
        max_tokens=config.DEEPSEEK_MAX_TOKENS,
        temperature=config.DEEPSEEK_TEMPERATURE
    )
    return DeepSeekAgent(deepseek_config)

```

## File ..\polymind\src\agents\manager.py:
```python
# Generated by Copilot
"""
Agent Manager - Quản lý tất cả agents trong PolyMind system

Centralized management cho tất cả AI agents.
"""

import os
from typing import Dict, List, Optional, Any
from dataclasses import dataclass

from . import BaseAgent, AgentType, AgentResponse
from .deepseek import DeepSeekAgent, create_deepseek_agent


@dataclass
class AgentInfo:
    """Thông tin về một agent."""
    name: str
    type: AgentType
    description: str
    is_available: bool
    capabilities: List[str]
    model_info: Optional[Dict[str, Any]] = None


class AgentManager:
    """
    Manager để quản lý và route requests đến các agents.
    
    Chức năng:
    - Registry các agents
    - Route messages đến appropriate agent
    - Load balancing và fallback
    - Agent health monitoring
    """
    
    def __init__(self):
        self.agents: Dict[str, BaseAgent] = {}
        self._default_agent: Optional[str] = None
    
    def register_agent(self, agent_id: str, agent: BaseAgent, is_default: bool = False):
        """
        Đăng ký agent vào manager.
        
        Args:
            agent_id: Unique ID cho agent
            agent: BaseAgent instance
            is_default: Có phải default agent không
        """
        self.agents[agent_id] = agent
        
        if is_default or self._default_agent is None:
            self._default_agent = agent_id
    
    def get_agent(self, agent_id: Optional[str] = None) -> Optional[BaseAgent]:
        """
        Lấy agent theo ID.
        
        Args:
            agent_id: ID của agent (None = default agent)
            
        Returns:
            BaseAgent instance hoặc None        """
        if agent_id is None:
            agent_id = self._default_agent
            
        if agent_id is None:
            return None
            
        return self.agents.get(agent_id)
    
    def list_agents(self) -> List[AgentInfo]:
        """Liệt kê tất cả agents có sẵn."""
        agent_infos = []
        
        for agent_id, agent in self.agents.items():
            info = agent.info
            agent_info = AgentInfo(
                name=info["name"],
                type=AgentType(info["type"]),
                description=info["description"],
                is_available=True,  # TODO: Implement health check
                capabilities=info.get("capabilities", []),
                model_info={
                    "model": info.get("model"),
                    "provider": info.get("provider")
                }
            )
            agent_infos.append(agent_info)
        
        return agent_infos
    
    async def chat(self, message: str, agent_id: Optional[str] = None, **kwargs) -> AgentResponse:
        """
        Gửi message đến agent.
        
        Args:
            message: Tin nhắn từ user
            agent_id: ID của agent (None = default)
            **kwargs: Tham số bổ sung
            
        Returns:
            AgentResponse
        """
        agent = self.get_agent(agent_id)
        
        if agent is None:
            # Fallback response
            return AgentResponse(
                content="Xin lỗi, agent không khả dụng. Vui lòng thử lại sau.",
                agent_type=AgentType.GENERAL,
                model_name="fallback",
                metadata={"error": True, "reason": "agent_unavailable"}
            )
        
        return await agent.chat(message, **kwargs)
    
    async def setup_default_agents(self):
        """Thiết lập các agents mặc định."""
        try:
            # DeepSeek agent (primary)
            deepseek_agent = create_deepseek_agent()
            self.register_agent("deepseek", deepseek_agent, is_default=True)
            
            print("✅ DeepSeek agent registered successfully")
            
        except Exception as e:
            print(f"❌ Failed to setup DeepSeek agent: {e}")
            print("💡 Hãy đảm bảo TOGETHER_API_KEY environment variable được set")
    
    async def health_check(self) -> Dict[str, Any]:
        """Kiểm tra health của tất cả agents."""
        health_status = {
            "total_agents": len(self.agents),
            "healthy_agents": 0,
            "agents": {}
        }
        
        for agent_id, agent in self.agents.items():
            try:
                # Simple health check bằng cách gọi info
                agent_info = agent.info
                health_status["agents"][agent_id] = {
                    "status": "healthy",
                    "info": agent_info
                }
                health_status["healthy_agents"] += 1
                
            except Exception as e:                health_status["agents"][agent_id] = {
                    "status": "unhealthy",
                    "error": str(e)
                }
        
        return health_status
    
    async def close_all(self):
        """Đóng tất cả agents."""
        for agent in self.agents.values():
            if hasattr(agent, 'close') and callable(getattr(agent, 'close', None)):
                try:
                    close_method = getattr(agent, 'close')
                    await close_method()
                except Exception as e:
                    print(f"Error closing agent: {e}")
    
    def get_agent_by_type(self, agent_type: AgentType) -> Optional[BaseAgent]:
        """Lấy agent theo type."""
        for agent in self.agents.values():
            if agent.agent_type == agent_type:
                return agent
        return None
    
    def get_capabilities(self) -> Dict[str, List[str]]:
        """Lấy capabilities của tất cả agents."""
        capabilities = {}
        
        for agent_id, agent in self.agents.items():
            info = agent.info
            capabilities[agent_id] = info.get("capabilities", [])
        
        return capabilities


# Global agent manager instance
agent_manager = AgentManager()

```

## File ..\polymind\src\agents\__init__.py:
```python
# Generated by Copilot
"""
PolyMind Agent System - Base Agent Interface

Định nghĩa interface cơ bản cho tất cả agents trong hệ thống.
"""

from abc import ABC, abstractmethod
from typing import Dict, List, Optional, Any, AsyncGenerator
from dataclasses import dataclass
from enum import Enum
import asyncio
import time


class AgentType(Enum):
    """Loại agent trong hệ thống."""
    GENERAL = "general"
    CODING = "coding" 
    ANALYSIS = "analysis"
    CREATIVE = "creative"
    DEEPSEEK = "deepseek"


class MessageRole(Enum):
    """Vai trò trong conversation."""
    USER = "user"
    ASSISTANT = "assistant"
    SYSTEM = "system"


@dataclass
class AgentMessage:
    """Tin nhắn trong conversation."""
    role: MessageRole
    content: str
    timestamp: float
    metadata: Optional[Dict[str, Any]] = None


@dataclass 
class AgentResponse:
    """Response từ agent."""
    content: str
    agent_type: AgentType
    model_name: str
    usage: Optional[Dict[str, Any]] = None
    metadata: Optional[Dict[str, Any]] = None
    timestamp: Optional[float] = None
    
    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = time.time()


class BaseAgent(ABC):
    """Base class cho tất cả agents."""
    
    def __init__(self, agent_type: AgentType, name: str, description: str):
        self.agent_type = agent_type
        self.name = name
        self.description = description
        self.conversation_history: List[AgentMessage] = []
    
    @abstractmethod
    async def chat(self, message: str, **kwargs) -> AgentResponse:
        """
        Gửi tin nhắn đến agent và nhận response.
        
        Args:
            message: Tin nhắn từ user
            **kwargs: Các tham số bổ sung
            
        Returns:
            AgentResponse với nội dung phản hồi
        """
        pass
    
    @abstractmethod
    async def stream_chat(self, message: str, **kwargs) -> AsyncGenerator[str, None]:
        """
        Stream response từ agent.
        
        Args:
            message: Tin nhắn từ user
            **kwargs: Các tham số bổ sung
            
        Yields:
            Từng phần của response
        """
        pass
    
    def add_message(self, role: MessageRole, content: str, metadata: Optional[Dict] = None):
        """Thêm tin nhắn vào lịch sử conversation."""
        message = AgentMessage(
            role=role,
            content=content,
            timestamp=time.time(),
            metadata=metadata
        )
        self.conversation_history.append(message)
    
    def clear_conversation(self):
        """Xóa lịch sử conversation."""
        self.conversation_history.clear()
    
    def get_conversation_context(self, max_messages: int = 10) -> List[Dict[str, str]]:
        """
        Lấy context conversation cho API calls.
        
        Args:
            max_messages: Số tin nhắn tối đa để lấy
            
        Returns:
            List các tin nhắn theo format API
        """
        recent_messages = self.conversation_history[-max_messages:]
        return [
            {"role": msg.role.value, "content": msg.content}
            for msg in recent_messages
        ]
    
    def get_system_prompt(self) -> str:
        """Lấy system prompt cho agent."""
        return f"You are {self.name}, {self.description}"
    
    @property
    def info(self) -> Dict[str, Any]:
        """Thông tin về agent."""
        return {
            "name": self.name,
            "type": self.agent_type.value,
            "description": self.description,
            "conversation_length": len(self.conversation_history)
        }

```

## File ..\polymind\src\routes\chat.py:
```python

```

## File ..\polymind\src\routes\dashboard.py:
```python

```

## File ..\polymind\src\services\health.py:
```python
# src/services/health.py
from fastapi import APIRouter

router = APIRouter(prefix="/health", tags=["health"])

@router.get("/")
async def health_check():
    return {
        "status": "healthy", 
        "timestamp": "2025-06-20T...",
        "version": "1.0.0"
    }

@router.get("/detailed")
async def detailed_health():
    return {
        "status": "healthy",
        "database": "connected",
        "memory_usage": "45%",
        "uptime": "2h 30m"
    }
```

## File ..\polymind\src\utils\async_logger.py:
```python
# Generated by Copilot
"""
High-Performance Async Logging System for PolyMind

Provides non-blocking, async-aware logging with performance optimization:
- Async queue-based logging to prevent I/O blocking
- Structured JSON logging for better traceability
- Rotating file handlers to manage disk space
- Configurable buffering for batch writes
- Context-aware logging for request tracing
"""

import asyncio
import json
import logging
import sys
import time
import uuid
from asyncio import Queue
from concurrent.futures import ThreadPoolExecutor
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, Optional, Union, List
from logging.handlers import RotatingFileHandler


class AsyncLogHandler:
    """
    Async-aware log handler với queue-based processing.
    
    Tất cả log records được đưa vào queue và xử lý bởi background thread,
    không block main event loop.
    """
    
    def __init__(
        self,
        max_queue_size: int = 10000,
        batch_size: int = 100,
        flush_interval: float = 1.0,
        max_workers: int = 2
    ):
        self.log_queue: Queue = Queue(maxsize=max_queue_size)
        self.batch_size = batch_size
        self.flush_interval = flush_interval
        self.executor = ThreadPoolExecutor(max_workers=max_workers)
        self.handlers: List[logging.Handler] = []
        self.is_running = False
        self._background_task: Optional[asyncio.Task] = None
        
    def add_handler(self, handler: logging.Handler) -> None:
        """Thêm handler để xử lý log records."""
        self.handlers.append(handler)
        
    async def start(self) -> None:
        """Khởi động background processing."""
        if self.is_running:
            return
            
        self.is_running = True
        self._background_task = asyncio.create_task(self._process_logs())
        
    async def stop(self) -> None:
        """Dừng background processing và flush remaining logs."""
        self.is_running = False
        if self._background_task:
            await self._background_task
            
        # Flush remaining logs
        await self._flush_remaining()
        
    async def log_async(self, record: logging.LogRecord) -> None:
        """Async log method - không block."""
        try:
            self.log_queue.put_nowait(record)
        except asyncio.QueueFull:
            # Fallback: log to stderr nếu queue full
            print(f"Log queue full, dropping: {record.getMessage()}", file=sys.stderr)
            
    async def _process_logs(self) -> None:
        """Background task xử lý log queue."""
        batch = []
        last_flush = time.time()
        
        while self.is_running or not self.log_queue.empty():
            try:
                # Collect batch hoặc timeout
                while len(batch) < self.batch_size:
                    try:
                        record = await asyncio.wait_for(
                            self.log_queue.get(), timeout=0.1
                        )
                        batch.append(record)
                    except asyncio.TimeoutError:
                        break
                
                # Flush nếu có batch hoặc timeout
                current_time = time.time()
                if batch and (
                    len(batch) >= self.batch_size or 
                    current_time - last_flush >= self.flush_interval
                ):
                    await self._flush_batch(batch)
                    batch.clear()
                    last_flush = current_time
                    
            except Exception as e:
                print(f"Error in log processing: {e}", file=sys.stderr)
                
        # Final flush
        if batch:
            await self._flush_batch(batch)
            
    async def _flush_batch(self, batch: List[logging.LogRecord]) -> None:
        """Flush batch of log records to handlers."""
        if not batch or not self.handlers:
            return
            
        def write_logs():
            for record in batch:
                for handler in self.handlers:
                    try:
                        handler.emit(record)
                    except Exception as e:
                        print(f"Handler error: {e}", file=sys.stderr)
                        
        # Chạy I/O trong thread pool
        loop = asyncio.get_event_loop()
        await loop.run_in_executor(self.executor, write_logs)
        
    async def _flush_remaining(self) -> None:
        """Flush all remaining logs."""
        remaining = []
        try:
            while True:
                record = self.log_queue.get_nowait()
                remaining.append(record)
        except asyncio.QueueEmpty:
            pass
            
        if remaining:
            await self._flush_batch(remaining)


class StructuredFormatter(logging.Formatter):
    """Formatter để tạo structured JSON logs."""
    
    def format(self, record: logging.LogRecord) -> str:
        """Format log record thành JSON structure."""
        log_data = {
            "timestamp": datetime.fromtimestamp(record.created).isoformat(),
            "level": record.levelname,
            "logger": record.name,
            "message": record.getMessage(),
            "module": record.module,
            "function": record.funcName,
            "line": record.lineno,
        }
        
        # Thêm context nếu có
        if hasattr(record, 'context'):
            log_data['context'] = getattr(record, 'context')
            
        # Thêm request_id nếu có
        if hasattr(record, 'request_id'):
            log_data['request_id'] = getattr(record, 'request_id')
            
        # Thêm exception info nếu có
        if record.exc_info:
            log_data['exception'] = self.formatException(record.exc_info)
            
        return json.dumps(log_data, ensure_ascii=False)


class AsyncLogger:
    """
    High-performance async logger với context support.
    
    Features:
    - Non-blocking logging via async queue
    - Structured JSON output
    - Request/context tracking
    - Rotating file handlers
    - Performance optimized
    """
    
    def __init__(self, name: str, async_handler: AsyncLogHandler):
        self.name = name
        self.async_handler = async_handler
        self._context: Dict[str, Any] = {}
        self._request_id: Optional[str] = None
        
    def set_context(self, **kwargs) -> None:
        """Set logging context for this logger instance."""
        self._context.update(kwargs)
        
    def clear_context(self) -> None:
        """Clear logging context."""
        self._context.clear()
        
    def set_request_id(self, request_id: str) -> None:
        """Set request ID for tracing."""
        self._request_id = request_id
        
    def generate_request_id(self) -> str:
        """Generate và set new request ID."""
        request_id = str(uuid.uuid4())[:8]
        self.set_request_id(request_id)
        return request_id
        
    async def _log(self, level: int, message: str, **kwargs) -> None:
        """Internal async logging method."""
        record = logging.LogRecord(
            name=self.name,
            level=level,
            pathname="",
            lineno=0,
            msg=message,
            args=(),
            exc_info=None
        )
        
        # Thêm context
        if self._context:
            setattr(record, 'context', self._context.copy())
            
        # Thêm request_id
        if self._request_id:
            setattr(record, 'request_id', self._request_id)
            
        # Thêm extra kwargs
        for key, value in kwargs.items():
            setattr(record, key, value)
            
        await self.async_handler.log_async(record)
        
    async def debug(self, message: str, **kwargs) -> None:
        """Log debug message."""
        await self._log(logging.DEBUG, message, **kwargs)
        
    async def info(self, message: str, **kwargs) -> None:
        """Log info message."""
        await self._log(logging.INFO, message, **kwargs)
        
    async def warning(self, message: str, **kwargs) -> None:
        """Log warning message."""
        await self._log(logging.WARNING, message, **kwargs)
        
    async def error(self, message: str, **kwargs) -> None:
        """Log error message."""
        await self._log(logging.ERROR, message, **kwargs)
        
    async def critical(self, message: str, **kwargs) -> None:
        """Log critical message."""
        await self._log(logging.CRITICAL, message, **kwargs)


class AsyncLoggerConfig:
    """Async-aware logger configuration manager."""
    
    _configured = False
    _async_handler: Optional[AsyncLogHandler] = None
    _loggers: Dict[str, AsyncLogger] = {}
    
    @classmethod
    async def configure_logging(
        cls,
        level: int = logging.INFO,
        log_to_file: bool = True,
        log_file_path: Optional[Path] = None,
        max_file_size: int = 10 * 1024 * 1024,  # 10MB
        backup_count: int = 5,
        structured: bool = True,
        max_queue_size: int = 10000,
        batch_size: int = 100,
        flush_interval: float = 1.0
    ) -> None:
        """
        Configure async logging system.
        
        Args:
            level: Logging level
            log_to_file: Enable file logging
            log_file_path: Path to log file
            max_file_size: Max size per log file
            backup_count: Number of backup files
            structured: Use JSON structured logging
            max_queue_size: Max async queue size
            batch_size: Batch size for processing
            flush_interval: Flush interval in seconds
        """
        if cls._configured:
            return
            
        # Create async handler
        cls._async_handler = AsyncLogHandler(
            max_queue_size=max_queue_size,
            batch_size=batch_size,
            flush_interval=flush_interval
        )
        
        # Formatter
        if structured:
            formatter = StructuredFormatter()
        else:
            formatter = logging.Formatter(
                "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
            )
            
        # Console handler (stderr)
        console_handler = logging.StreamHandler(sys.stderr)
        console_handler.setLevel(level)
        console_handler.setFormatter(formatter)
        cls._async_handler.add_handler(console_handler)
        
        # File handler với rotation
        if log_to_file:
            if log_file_path is None:
                log_file_path = Path("logs/polymind.log")
                
            log_file_path.parent.mkdir(parents=True, exist_ok=True)
            
            file_handler = RotatingFileHandler(
                log_file_path,
                maxBytes=max_file_size,
                backupCount=backup_count,
                encoding="utf-8"
            )
            file_handler.setLevel(level)
            file_handler.setFormatter(formatter)
            cls._async_handler.add_handler(file_handler)
            
        # Start async processing
        await cls._async_handler.start()
        
        cls._configured = True
        
    @classmethod
    async def get_logger(cls, name: str) -> AsyncLogger:
        """Get async logger instance."""
        if not cls._configured:
            await cls.configure_logging()
            
        if name not in cls._loggers and cls._async_handler:
            cls._loggers[name] = AsyncLogger(name, cls._async_handler)
            
        return cls._loggers[name]
        
    @classmethod
    async def shutdown(cls) -> None:
        """Shutdown logging system."""
        if cls._async_handler:
            await cls._async_handler.stop()
            cls._configured = False


# Global async logger instance
_global_config = AsyncLoggerConfig()


async def get_async_logger(name: str) -> AsyncLogger:
    """
    Get async logger instance.
    
    Args:
        name: Logger name (typically __name__)
        
    Returns:
        AsyncLogger instance
        
    Example:
        logger = await get_async_logger(__name__)
        await logger.info("Async log message")
    """
    return await _global_config.get_logger(name)


async def configure_async_logging(**kwargs) -> None:
    """Configure async logging system."""
    await _global_config.configure_logging(**kwargs)


async def shutdown_logging() -> None:
    """Shutdown logging system gracefully."""
    await _global_config.shutdown()


# Context manager for request tracing
class LogContext:
    """Context manager cho request-scoped logging."""
    
    def __init__(self, logger: AsyncLogger, **context):
        self.logger = logger
        self.context = context
        self.old_context = {}
        
    async def __aenter__(self):
        self.old_context = self.logger._context.copy()
        self.logger.set_context(**self.context)
        return self.logger
        
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        self.logger._context = self.old_context


# Decorator for automatic request ID generation
def with_request_id(func):
    """Decorator tự động tạo request ID cho async functions."""
    async def wrapper(*args, **kwargs):
        logger = await get_async_logger(func.__module__)
        request_id = logger.generate_request_id()
        
        async with LogContext(logger, request_id=request_id):
            await logger.info(f"Starting {func.__name__}", function=func.__name__)
            try:
                result = await func(*args, **kwargs)
                await logger.info(f"Completed {func.__name__}", function=func.__name__)
                return result
            except Exception as e:
                await logger.error(
                    f"Error in {func.__name__}: {e}", 
                    function=func.__name__, 
                    error=str(e)
                )
                raise
                
    return wrapper

```

## File ..\polymind\src\utils\logger.py:
```python
# Generated by Copilot
"""
High-Performance Async Logging System for PolyMind - Text Format

Provides non-blocking, async-aware logging with traditional text formatting:
- Async queue-based logging to prevent I/O blocking
- Traditional text format for better readability
- Rotating file handlers to manage disk space
- Configurable buffering for batch writes
- Context-aware logging for request tracing
"""

import asyncio
import logging
import sys
import time
import uuid
from asyncio import Queue
from concurrent.futures import ThreadPoolExecutor
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, Optional, Union, List
from logging.handlers import RotatingFileHandler


class AsyncLogHandler:
    """
    Async-aware log handler với queue-based processing.
    
    Tất cả log records được đưa vào queue và xử lý bởi background thread,
    không block main event loop.
    """
    
    def __init__(
        self,
        max_queue_size: int = 10000,
        batch_size: int = 100,
        flush_interval: float = 1.0,
        max_workers: int = 2
    ):
        self.log_queue: Queue = Queue(maxsize=max_queue_size)
        self.batch_size = batch_size
        self.flush_interval = flush_interval
        self.executor = ThreadPoolExecutor(max_workers=max_workers)
        self.handlers: List[logging.Handler] = []
        self.is_running = False
        self._background_task: Optional[asyncio.Task] = None
        
    def add_handler(self, handler: logging.Handler) -> None:
        """Thêm handler để xử lý log records."""
        self.handlers.append(handler)
        
    async def start(self) -> None:
        """Khởi động background processing."""
        if self.is_running:
            return
            
        self.is_running = True
        self._background_task = asyncio.create_task(self._process_logs())
        
    async def stop(self) -> None:
        """Dừng background processing và flush remaining logs."""
        self.is_running = False
        if self._background_task:
            await self._background_task
            
        # Flush remaining logs
        await self._flush_remaining()
        
    async def log_async(self, record: logging.LogRecord) -> None:
        """Async log method - không block."""
        try:
            self.log_queue.put_nowait(record)
        except asyncio.QueueFull:
            # Fallback: log to stderr nếu queue full
            print(f"Log queue full, dropping: {record.getMessage()}", file=sys.stderr)
            
    async def _process_logs(self) -> None:
        """Background task xử lý log queue."""
        batch = []
        last_flush = time.time()
        
        while self.is_running or not self.log_queue.empty():
            try:
                # Collect batch hoặc timeout
                while len(batch) < self.batch_size:
                    try:
                        record = await asyncio.wait_for(
                            self.log_queue.get(), timeout=0.1
                        )
                        batch.append(record)
                    except asyncio.TimeoutError:
                        break
                
                # Flush nếu có batch hoặc timeout
                current_time = time.time()
                if batch and (
                    len(batch) >= self.batch_size or 
                    current_time - last_flush >= self.flush_interval
                ):
                    await self._flush_batch(batch)
                    batch.clear()
                    last_flush = current_time
                    
            except Exception as e:
                print(f"Error in log processing: {e}", file=sys.stderr)
                
        # Final flush
        if batch:
            await self._flush_batch(batch)
            
    async def _flush_batch(self, batch: List[logging.LogRecord]) -> None:
        """Flush batch of log records to handlers."""
        if not batch or not self.handlers:
            return
            
        def write_logs():
            for record in batch:
                for handler in self.handlers:
                    try:
                        handler.emit(record)
                    except Exception as e:
                        print(f"Handler error: {e}", file=sys.stderr)
                        
        # Chạy I/O trong thread pool
        loop = asyncio.get_event_loop()
        await loop.run_in_executor(self.executor, write_logs)
        
    async def _flush_remaining(self) -> None:
        """Flush all remaining logs."""
        remaining = []
        try:
            while True:
                record = self.log_queue.get_nowait()
                remaining.append(record)
        except asyncio.QueueEmpty:
            pass
            
        if remaining:
            await self._flush_batch(remaining)


class TextFormatter(logging.Formatter):
    """Formatter để tạo traditional text logs với context support."""
    
    def __init__(self, include_context: bool = True):
        # Format: 2025-06-20 09:15:30,123 [INFO] module.function:42 - Message
        super().__init__(
            fmt="%(asctime)s [%(levelname)s] %(name)s - %(message)s",
            datefmt="%Y-%m-%d %H:%M:%S"
        )
        self.include_context = include_context
    
    def format(self, record: logging.LogRecord) -> str:
        """Format log record thành text với context support."""
        # Base formatting
        formatted = super().format(record)
        
        if not self.include_context:
            return formatted
              # Thêm context information nếu có
        context_parts = []
        
        # Thêm request_id nếu có
        request_id = getattr(record, 'request_id', None)
        if request_id:
            context_parts.append(f"req_id={request_id}")
            
        # Thêm context nếu có
        context = getattr(record, 'context', None)
        if context and isinstance(context, dict):
            context_str = " ".join([f"{k}={v}" for k, v in context.items()])
            context_parts.append(context_str)
            
        # Thêm function info nếu có
        if hasattr(record, 'funcName') and record.funcName:
            context_parts.append(f"func={record.funcName}")
            
        if hasattr(record, 'lineno') and record.lineno:
            context_parts.append(f"line={record.lineno}")
        
        # Append context to message
        if context_parts:
            context_info = " | ".join(context_parts)
            formatted = f"{formatted} | {context_info}"
            
        # Thêm exception info nếu có
        if record.exc_info:
            formatted += "\n" + self.formatException(record.exc_info)
            
        return formatted


class AsyncLogger:
    """
    High-performance async logger với traditional text format.
    
    Features:
    - Non-blocking logging via async queue
    - Traditional text output for readability
    - Request/context tracking
    - Rotating file handlers
    - Performance optimized
    """
    
    def __init__(self, name: str, async_handler: AsyncLogHandler):
        self.name = name
        self.async_handler = async_handler
        self._context: Dict[str, Any] = {}
        self._request_id: Optional[str] = None
        
    def set_context(self, **kwargs) -> None:
        """Set logging context for this logger instance."""
        self._context.update(kwargs)
        
    def clear_context(self) -> None:
        """Clear logging context."""
        self._context.clear()
        
    def set_request_id(self, request_id: str) -> None:
        """Set request ID for tracing."""
        self._request_id = request_id
        
    def generate_request_id(self) -> str:
        """Generate và set new request ID."""
        request_id = str(uuid.uuid4())[:8]
        self.set_request_id(request_id)
        return request_id
        
    async def _log(self, level: int, message: str, **kwargs) -> None:
        """Internal async logging method."""
        record = logging.LogRecord(
            name=self.name,
            level=level,
            pathname="",
            lineno=0,
            msg=message,
            args=(),
            exc_info=None
        )
        
        # Thêm context
        if self._context:
            setattr(record, 'context', self._context.copy())
            
        # Thêm request_id
        if self._request_id:
            setattr(record, 'request_id', self._request_id)
            
        # Thêm extra kwargs
        for key, value in kwargs.items():
            setattr(record, key, value)
            
        await self.async_handler.log_async(record)
        
    async def debug(self, message: str, **kwargs) -> None:
        """Log debug message."""
        await self._log(logging.DEBUG, message, **kwargs)
        
    async def info(self, message: str, **kwargs) -> None:
        """Log info message."""
        await self._log(logging.INFO, message, **kwargs)
        
    async def warning(self, message: str, **kwargs) -> None:
        """Log warning message."""
        await self._log(logging.WARNING, message, **kwargs)
        
    async def error(self, message: str, **kwargs) -> None:
        """Log error message."""
        await self._log(logging.ERROR, message, **kwargs)
        
    async def critical(self, message: str, **kwargs) -> None:
        """Log critical message."""
        await self._log(logging.CRITICAL, message, **kwargs)


class AsyncLoggerConfig:
    """Async-aware logger configuration manager với text format."""
    
    _configured = False
    _async_handler: Optional[AsyncLogHandler] = None
    _loggers: Dict[str, AsyncLogger] = {}
    
    @classmethod
    async def configure_logging(
        cls,
        level: int = logging.INFO,
        log_to_file: bool = True,
        log_file_path: Optional[Path] = None,
        max_file_size: int = 10 * 1024 * 1024,  # 10MB
        backup_count: int = 5,
        include_context: bool = True,
        max_queue_size: int = 10000,
        batch_size: int = 100,
        flush_interval: float = 1.0
    ) -> None:
        """
        Configure async logging system với text format.
        
        Args:
            level: Logging level
            log_to_file: Enable file logging
            log_file_path: Path to log file
            max_file_size: Max size per log file
            backup_count: Number of backup files
            include_context: Include context in text format
            max_queue_size: Max async queue size
            batch_size: Batch size for processing
            flush_interval: Flush interval in seconds
        """
        if cls._configured:
            return
            
        # Create async handler
        cls._async_handler = AsyncLogHandler(
            max_queue_size=max_queue_size,
            batch_size=batch_size,
            flush_interval=flush_interval
        )
        
        # Formatter
        formatter = TextFormatter(include_context=include_context)
            
        # Console handler (stderr)
        console_handler = logging.StreamHandler(sys.stderr)
        console_handler.setLevel(level)
        console_handler.setFormatter(formatter)
        cls._async_handler.add_handler(console_handler)
        
        # File handler với rotation
        if log_to_file:
            if log_file_path is None:
                log_file_path = Path("logs/polymind.log")
                
            log_file_path.parent.mkdir(parents=True, exist_ok=True)
            
            file_handler = RotatingFileHandler(
                log_file_path,
                maxBytes=max_file_size,
                backupCount=backup_count,
                encoding="utf-8"
            )
            file_handler.setLevel(level)
            file_handler.setFormatter(formatter)
            cls._async_handler.add_handler(file_handler)
            
        # Start async processing
        await cls._async_handler.start()
        
        cls._configured = True
        
    @classmethod
    async def get_logger(cls, name: str) -> AsyncLogger:
        """Get async logger instance."""
        if not cls._configured:
            await cls.configure_logging()
            
        if name not in cls._loggers and cls._async_handler:
            cls._loggers[name] = AsyncLogger(name, cls._async_handler)
            
        return cls._loggers[name]
        
    @classmethod
    async def shutdown(cls) -> None:
        """Shutdown logging system."""
        if cls._async_handler:
            await cls._async_handler.stop()
            cls._configured = False


# Global async logger instance
_global_config = AsyncLoggerConfig()


async def get_logger(name: str) -> AsyncLogger:
    """
    Get async logger instance với text format.
    
    Args:
        name: Logger name (typically __name__)
        
    Returns:
        AsyncLogger instance
        
    Example:
        logger = await get_logger(__name__)
        await logger.info("Text log message")
    """
    return await _global_config.get_logger(name)


async def configure_logging(**kwargs) -> None:
    """Configure async logging system với text format."""
    await _global_config.configure_logging(**kwargs)


async def shutdown_logging() -> None:
    """Shutdown logging system gracefully."""
    await _global_config.shutdown()


# Context manager for request tracing
class LogContext:
    """Context manager cho request-scoped logging."""
    
    def __init__(self, logger: AsyncLogger, **context):
        self.logger = logger
        self.context = context
        self.old_context = {}
        
    async def __aenter__(self):
        self.old_context = self.logger._context.copy()
        self.logger.set_context(**self.context)
        return self.logger
        
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        self.logger._context = self.old_context


# Decorator for automatic request ID generation
def with_request_id(func):
    """Decorator tự động tạo request ID cho async functions."""
    async def wrapper(*args, **kwargs):
        logger = await get_logger(func.__module__)
        request_id = logger.generate_request_id()
        
        async with LogContext(logger, request_id=request_id):
            await logger.info(f"Starting {func.__name__}")
            try:
                result = await func(*args, **kwargs)
                await logger.info(f"Completed {func.__name__}")
                return result
            except Exception as e:
                await logger.error(f"Error in {func.__name__}: {e}")
                raise
                
    return wrapper


# Convenience functions for quick logging
async def log_info(message: str, logger_name: str = "__main__", **kwargs) -> None:
    """Quick info logging."""
    logger = await get_logger(logger_name)
    await logger.info(message, **kwargs)


async def log_error(message: str, logger_name: str = "__main__", **kwargs) -> None:
    """Quick error logging."""
    logger = await get_logger(logger_name)
    await logger.error(message, **kwargs)


async def log_debug(message: str, logger_name: str = "__main__", **kwargs) -> None:
    """Quick debug logging."""
    logger = await get_logger(logger_name)
    await logger.debug(message, **kwargs)

```

## File ..\polymind\src\utils\__init__.py:
```python
# Generated by Copilot
"""Utility modules for the server."""

from .async_logger import get_async_logger, configure_async_logging, shutdown_logging

__all__ = ["get_async_logger", "configure_async_logging", "shutdown_logging"]

```

