# C·∫•u tr√∫c D·ª± √°n nh∆∞ sau:

```
../polymind/backend
‚îú‚îÄ‚îÄ __init__.py
‚îú‚îÄ‚îÄ adapters
‚îÇ   ‚îî‚îÄ‚îÄ .gitkeep
‚îú‚îÄ‚îÄ agents
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ deepseek.py
‚îÇ   ‚îî‚îÄ‚îÄ manager.py
‚îú‚îÄ‚îÄ config.py
‚îú‚îÄ‚îÄ core
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îî‚îÄ‚îÄ lifecycle.py
‚îú‚îÄ‚îÄ main.py
‚îú‚îÄ‚îÄ routes
‚îÇ   ‚îú‚îÄ‚îÄ chat.py
‚îÇ   ‚îî‚îÄ‚îÄ dashboard.py
‚îú‚îÄ‚îÄ services
‚îÇ   ‚îî‚îÄ‚îÄ health.py
‚îú‚îÄ‚îÄ utils
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îî‚îÄ‚îÄ logger.py
‚îî‚îÄ‚îÄ websocket
    ‚îú‚îÄ‚îÄ __init__.py
    ‚îú‚îÄ‚îÄ chat_handler.py
    ‚îî‚îÄ‚îÄ connection_manager.py
```

# Danh s√°ch chi ti·∫øt c√°c file:

## File ../polymind/backend\config.py:
```python
# Generated by Copilot
"""
Configuration management for PolyMind project.
"""

import os
from typing import Optional


class Config:
    """Application configuration."""
    
    # Together.xyz API configuration
    TOGETHER_API_KEY: Optional[str] = os.getenv("TOGETHER_API_KEY")
    TOGETHER_BASE_URL: str = "https://api.together.xyz/v1"
    
    # DeepSeek model configuration
    DEEPSEEK_MODEL: str = "deepseek-ai/DeepSeek-V3"
    DEEPSEEK_MAX_TOKENS: int = 4000
    DEEPSEEK_TEMPERATURE: float = 0.7
    
    # Application settings
    DEBUG: bool = os.getenv("DEBUG", "false").lower() == "true"
    HOST: str = os.getenv("HOST", "127.0.0.1")
    PORT: int = int(os.getenv("PORT", "8000"))
    
    @classmethod
    def check_required_env(cls) -> bool:
        """Ki·ªÉm tra c√°c environment variables b·∫Øt bu·ªôc."""
        if not cls.TOGETHER_API_KEY:
            print("‚ùå TOGETHER_API_KEY environment variable is not set")
            print("üí° Please set your Together.xyz API key:")
            print("   export TOGETHER_API_KEY=your_api_key_here")
            return False
        return True


# Global config instance
config = Config()
```

## File ../polymind/backend\main.py:
```python
import sys
from fastapi import FastAPI, WebSocket, WebSocketDisconnect
from fastapi.staticfiles import StaticFiles
from fastapi.responses import FileResponse
from pathlib import Path
import json
import asyncio
from datetime import datetime
from backend.services.health import router as health_router
from backend.agents.manager import agent_manager
from backend.agents import AgentType, AgentResponse
from backend.config import config
from backend.utils.logger import get_async_logger


# Quan tr·ªçng: Import LifecycleManager v√† lifespan
from backend.core import lifecycle_manager, lifespan

logger = get_async_logger(__name__)

# S·ª≠ d·ª•ng lifespan trong kh·ªüi t·∫°o FastAPI
app = FastAPI(
    title="PolyMind App",
    description="Fast modern AI service framework",
    lifespan=lifespan,  # T√≠ch h·ª£p lifecycle manager
)


# WebSocket connection manager
class ConnectionManager:
    def __init__(self):
        # S·ª≠ d·ª•ng set thay v√¨ list
        self.active_connections: set[WebSocket] = set()
        self._lock = asyncio.Lock()  # Th√™m lock cho thread-safe

    async def connect(self, websocket: WebSocket):
        await websocket.accept()
        async with self._lock:
            self.active_connections.add(websocket)
        logger.info(f"üîå New connection. Total: {len(self.active_connections)}")

    def disconnect(self, websocket: WebSocket):
        self.active_connections.remove(websocket)
        # Log disconnection (using sync logging for simplicity in sync method)
        if logger:
            import asyncio

            async def log_disconnect():
                # Generated by Copilot
                logger.info(
                    f"üîå WebSocket connection closed. Remaining connections: {len(self.active_connections)}"
                )

            try:
                loop = asyncio.get_event_loop()
                loop.create_task(log_disconnect())
            except:
                pass  # Failsafe if no event loop

    async def send_personal_message(self, message: str, websocket: WebSocket):
        await websocket.send_text(message)


async def broadcast(self, message: str):
    """Broadcast message to all active connections efficiently"""
    tasks = []
    async with self._lock:
        # T·∫°o b·∫£n sao ƒë·ªÉ tr√°nh thay ƒë·ªïi trong khi l·∫∑p
        connections = list(self.active_connections)

    for connection in connections:
        tasks.append(self.send_personal_message(message, connection))

    await asyncio.gather(*tasks, return_exceptions=True)


manager = ConnectionManager()


# WebSocket endpoint for chat
@app.websocket("/ws/chat")
async def websocket_endpoint(websocket: WebSocket):
    await manager.connect(websocket)

    try:
        while True:
            data = await websocket.receive_text()

            # Gi·ªõi h·∫°n k√≠ch th∆∞·ªõc message (v√≠ d·ª•: 10KB)
            if len(data) > 10240:
                await manager.send_personal_message(
                    json.dumps({"type": "error", "content": "Message too large"}),
                    websocket,
                )
                continue

            message_data = json.loads(data)

            # L·∫•y th√¥ng tin t·ª´ message
            user_message = message_data.get("content", "")
            agent_id = message_data.get("agent", "deepseek")  # Default to deepseek
            is_streaming = message_data.get("streaming", False)

            # Log incoming message
            logger.info(
                f"üí¨ Received message for agent '{agent_id}' (streaming: {is_streaming}): {user_message[:100]}{'...' if len(user_message) > 100 else ''}"
            )

            try:
                if is_streaming:
                    # Streaming response
                    await manager.send_personal_message(
                        json.dumps({"type": "ai_typing", "agent": agent_id}), websocket
                    )

                    agent = agent_manager.get_agent(agent_id)
                    if agent:
                        response_content = ""
                        stream = await agent.stream_chat(user_message)
                        async for chunk in stream:
                            response_content += chunk
                            await manager.send_personal_message(
                                json.dumps(
                                    {
                                        "type": "ai_chunk",
                                        "content": chunk,
                                        "agent": agent_id,
                                    }
                                ),
                                websocket,
                            )
                        # G·ª≠i final response
                        await manager.send_personal_message(
                            json.dumps(
                                {
                                    "type": "ai_response",
                                    "content": response_content,
                                    "timestamp": datetime.now().isoformat(),
                                    "agent": agent_id,
                                }
                            ),
                            websocket,
                        )

                        # Log successful streaming response
                        logger.info(
                            f"‚úÖ Streaming response completed for agent '{agent_id}' - {len(response_content)} characters"
                        )
                    else:
                        logger.error(f"‚ùå Agent '{agent_id}' kh√¥ng kh·∫£ d·ª•ng")
                        await manager.send_personal_message(
                            json.dumps(
                                {
                                    "type": "error",
                                    "content": f"Agent '{agent_id}' kh√¥ng kh·∫£ d·ª•ng",
                                    "timestamp": datetime.now().isoformat(),
                                }
                            ),
                            websocket,
                        )
                else:
                    # Regular response
                    response = await agent_manager.chat(user_message, agent_id)

                    await manager.send_personal_message(
                        json.dumps(
                            {
                                "type": "ai_response",
                                "content": response.content,
                                "timestamp": datetime.now().isoformat(),
                                "agent": agent_id,
                                "model": response.model_name,
                            }
                        ),
                        websocket,
                    )
                    # Log successful regular response
                    logger.info(
                        f"‚úÖ Regular response completed for agent '{agent_id}' using model '{response.model_name}' - {len(response.content)} characters"
                    )

            except Exception as e:
                # Log error details
                logger.error(
                    f"‚ùå Error processing message for agent '{agent_id}': {str(e)}"
                )
                # G·ª≠i error response
                await manager.send_personal_message(
                    json.dumps(
                        {
                            "type": "error",
                            "content": f"L·ªói x·ª≠ l√Ω: {str(e)}",
                            "timestamp": datetime.now().isoformat(),
                        }
                    ),
                    websocket,
                )

    except WebSocketDisconnect:
        logger.info("üîå WebSocket client disconnected")
        manager.disconnect(websocket)
    except Exception as e:
        logger.error(f"‚ùå WebSocket error: {str(e)}")
        manager.disconnect(websocket)


# Mount static files
app.mount("/static", StaticFiles(directory="frontend"), name="static")

# Include API routers
app.include_router(health_router)


# Serve frontend at root
@app.get("/")
async def serve_frontend():
    """Serve the main frontend page."""
    return FileResponse("frontend/index.html")


@app.get("/chat")
async def serve_chat():
    """Serve the main chat page."""
    return FileResponse("frontend/chat.html")


@app.get("/api")
async def api_root():
    """API root endpoint."""
    return {"status": "ok", "message": "PolyMind API is running"}


@app.get("/api/chat/agents")
async def get_chat_agents():
    """Get available chat agents."""
    agents = []
    for agent_id, agent_instance in agent_manager.agents.items():
        agent_info = agent_instance.info
        agents.append(
            {
                "id": agent_id,
                "name": agent_info["name"],
                "description": agent_info["description"],
                "type": agent_info["type"],
                "conversation_length": agent_info.get("conversation_length", 0),
            }
        )

    return {"agents": agents}


@app.get("/api/chat/agents/health")
async def get_agents_health():
    """Ki·ªÉm tra health c·ªßa t·∫•t c·∫£ agents."""
    return await agent_manager.health_check()


def main() -> None:
    """Entry point ƒë·ªÉ ch·∫°y development server."""
    import uvicorn

    try:
        logger.info(f"üöÄ Starting server at {config.HOST}:{config.PORT}")
        logger.info(f"üîß Debug mode: {'ON' if config.DEBUG else 'OFF'}")

        uvicorn.run(
            "backend.main:app",
            host=config.HOST,
            port=config.PORT,
            reload=config.DEBUG,
            log_config=None,  # S·ª≠ d·ª•ng logging c·ªßa ch√∫ng ta, kh√¥ng d√πng c·ªßa Uvicorn
        )

    except KeyboardInterrupt:
        # Ng∆∞·ªùi d√πng nh·∫•n Ctrl+C ƒë·ªÉ d·ª´ng server
        logger.info("\nüõë Server shutdown requested by user")

    except Exception as e:
        # L·ªói nghi√™m tr·ªçng khi kh·ªüi ƒë·ªông server
        logger.error(f"üí• Server startup failed: {e}")
        logger.exception("Server startup error details:")
        sys.exit(1)

    finally:
        # Lu√¥n ch·∫°y ph·∫ßn n√†y d√π c√≥ l·ªói hay kh√¥ng
        logger.info("üîö PolyMind server stopped")


if __name__ == "__main__":
    # Ch·ªâ kh·ªüi t·∫°o logger ·ªü main thread
    logger = get_async_logger("server_main")

    try:
        logger.info("üöÄ Starting PolyMind server in development mode")
        main()
    except Exception as e:
        logger.exception("üí• Critical error in main thread")
        sys.exit(1)

```

## File ../polymind/backend\__init__.py:
```python
# Generated by Copilot
"""
PolyMind
Fast, modern AI service framework for vector database operations.
"""

__version__ = "0.1.0"
__author__ = "Mai Th√†nh Duy An"
__email__ = "tiachop0102@gmail.com"

# Import c√°c module ch√≠nh ƒë·ªÉ d·ªÖ d√†ng import t·ª´ package
from .main import app
# from .config import settings

# Public API - nh·ªØng g√¨ c√≥ th·ªÉ import t·ª´ b√™n ngo√†i
__all__ = [
    "app",
    "__version__",
]
```

## File ../polymind/backend\agents\deepseek.py:
```python
# Generated by Copilot
"""
DeepSeek V3 Agent Integration for PolyMind

Tri·ªÉn khai agent s·ª≠ d·ª•ng DeepSeek V3 model th√¥ng qua Together.xyz API.
"""

import os
import asyncio
import httpx
import json
from typing import Dict, List, Optional, Any, AsyncGenerator
from dataclasses import dataclass

from . import BaseAgent, AgentType, AgentResponse, MessageRole
from ..config import config


@dataclass
class DeepSeekConfig:
    """C·∫•u h√¨nh cho DeepSeek agent."""
    api_key: str
    base_url: str = "https://api.together.xyz/v1"
    model: str = "deepseek-ai/DeepSeek-V3"
    max_tokens: int = 2048
    temperature: float = 0.7
    timeout: int = 30


class DeepSeekAgent(BaseAgent):
    """
    DeepSeek V3 Agent s·ª≠ d·ª•ng Together.xyz API.
    
    Agent n√†y cung c·∫•p kh·∫£ nƒÉng:
    - Reasoning m·∫°nh m·∫Ω
    - Code generation v√† debugging
    - Ph√¢n t√≠ch v√† gi·∫£i quy·∫øt v·∫•n ƒë·ªÅ
    - H·ªó tr·ª£ ti·∫øng Vi·ªát
    """
    
    def __init__(self, config: DeepSeekConfig):
        super().__init__(
            agent_type=AgentType.DEEPSEEK,
            name="DeepSeek V3",
            description="AI Agent with advanced reasoning capabilities powered by DeepSeek V3"
        )
        
        self.config = config
        self.client = httpx.AsyncClient(
            base_url=config.base_url,
            timeout=config.timeout,
            headers={
                "Authorization": f"Bearer {config.api_key}",
                "Content-Type": "application/json"
            }
        )
    
    async def chat(self, message: str, **kwargs) -> AgentResponse:
        """
        G·ª≠i tin nh·∫Øn ƒë·∫øn DeepSeek V3 v√† nh·∫≠n response.
        
        Args:
            message: Tin nh·∫Øn t·ª´ user
            **kwargs: Tham s·ªë b·ªï sung (temperature, max_tokens, etc.)
            
        Returns:
            AgentResponse v·ªõi ph·∫£n h·ªìi t·ª´ DeepSeek V3
        """
        try:
            # Th√™m tin nh·∫Øn user v√†o conversation
            self.add_message(MessageRole.USER, message)
            
            # Chu·∫©n b·ªã messages cho API
            messages = self._prepare_messages()
            
            # G·ªçi API
            response = await self._make_api_call(messages, **kwargs)
            
            # Parse response
            assistant_message = response["choices"][0]["message"]["content"]
            usage = response.get("usage", {})
            
            # Th√™m response v√†o conversation
            self.add_message(MessageRole.ASSISTANT, assistant_message)
            
            return AgentResponse(
                content=assistant_message,
                agent_type=self.agent_type,
                model_name=self.config.model,
                usage=usage,
                metadata={"response_id": response.get("id")}
            )
            
        except Exception as e:
            error_msg = f"L·ªói khi g·ªçi DeepSeek API: {str(e)}"
            return AgentResponse(
                content=error_msg,
                agent_type=self.agent_type,
                model_name=self.config.model,
                metadata={"error": True, "error_type": type(e).__name__}
            )
    
    async def stream_chat(self, message: str, **kwargs) -> AsyncGenerator[str, None]:
        """
        Stream response t·ª´ DeepSeek V3.
        
        Args:
            message: Tin nh·∫Øn t·ª´ user
            **kwargs: Tham s·ªë b·ªï sung
            
        Yields:
            T·ª´ng ph·∫ßn c·ªßa response
        """
        try:
            # Th√™m tin nh·∫Øn user v√†o conversation
            self.add_message(MessageRole.USER, message)
            
            # Chu·∫©n b·ªã messages cho API
            messages = self._prepare_messages()
            
            # Stream API call
            full_response = ""
            async for chunk in self._stream_api_call(messages, **kwargs):
                if chunk:
                    full_response += chunk
                    yield chunk
            
            # Th√™m full response v√†o conversation
            if full_response:
                self.add_message(MessageRole.ASSISTANT, full_response)
                
        except Exception as e:
            yield f"L·ªói khi stream t·ª´ DeepSeek API: {str(e)}"
    
    def _prepare_messages(self) -> List[Dict[str, str]]:
        """Chu·∫©n b·ªã messages cho API call."""
        messages = [{"role": "system", "content": self._get_enhanced_system_prompt()}]
        
        # Th√™m conversation context
        conversation_messages = self.get_conversation_context(max_messages=20)
        messages.extend(conversation_messages)
        
        return messages
    
    def _get_enhanced_system_prompt(self) -> str:
        """System prompt ƒë∆∞·ª£c t·ªëi ∆∞u cho DeepSeek V3."""
        return """B·∫°n l√† DeepSeek V3, m·ªôt AI assistant th√¥ng minh v·ªõi kh·∫£ nƒÉng reasoning m·∫°nh m·∫Ω.

ƒê·∫∑c ƒëi·ªÉm c·ªßa b·∫°n:
- Suy lu·∫≠n logic v√† ph√¢n t√≠ch s√¢u s·∫Øc
- H·ªó tr·ª£ l·∫≠p tr√¨nh v√† debugging xu·∫•t s·∫Øc  
- Gi·∫£i th√≠ch r√µ r√†ng, d·ªÖ hi·ªÉu
- H·ªó tr·ª£ ti·∫øng Vi·ªát t·ª± nhi√™n
- Cung c·∫•p examples v√† code khi c·∫ßn thi·∫øt

H√£y tr·∫£ l·ªùi m·ªôt c√°ch chi ti·∫øt, logic v√† h·ªØu √≠ch. S·ª≠ d·ª•ng markdown formatting khi ph√π h·ª£p."""
    
    async def _make_api_call(self, messages: List[Dict], **kwargs) -> Dict[str, Any]:
        """Th·ª±c hi·ªán API call ƒë·∫øn Together.xyz."""
        payload = {
            "model": self.config.model,
            "messages": messages,
            "max_tokens": kwargs.get("max_tokens", self.config.max_tokens),
            "temperature": kwargs.get("temperature", self.config.temperature),
            "stream": False
        }
        
        response = await self.client.post("/chat/completions", json=payload)
        response.raise_for_status()
        return response.json()
    
    async def _stream_api_call(self, messages: List[Dict], **kwargs) -> AsyncGenerator[str, None]:
        """Stream API call ƒë·∫øn Together.xyz."""
        payload = {
            "model": self.config.model,
            "messages": messages,
            "max_tokens": kwargs.get("max_tokens", self.config.max_tokens),
            "temperature": kwargs.get("temperature", self.config.temperature),
            "stream": True
        }
        
        async with self.client.stream("POST", "/chat/completions", json=payload) as response:
            response.raise_for_status()
            
            async for line in response.aiter_lines():
                if line.startswith("data: "):
                    data = line[6:]  # Remove "data: " prefix
                    
                    if data == "[DONE]":
                        break
                    
                    try:
                        json_data = json.loads(data)
                        delta = json_data["choices"][0]["delta"]
                        
                        if "content" in delta:
                            yield delta["content"]
                            
                    except (json.JSONDecodeError, KeyError, IndexError):
                        continue
    
    async def analyze_code(self, code: str, language: str = "python") -> AgentResponse:
        """
        Ph√¢n t√≠ch code v√† ƒë∆∞a ra suggestions.
        
        Args:
            code: Source code c·∫ßn ph√¢n t√≠ch
            language: Ng√¥n ng·ªØ l·∫≠p tr√¨nh
            
        Returns:
            AgentResponse v·ªõi ph√¢n t√≠ch code
        """
        prompt = f"""H√£y ph√¢n t√≠ch ƒëo·∫°n code {language} sau v√† ƒë∆∞a ra feedback:

```{language}
{code}
```

Vui l√≤ng ph√¢n t√≠ch:
1. Code quality v√† best practices
2. Potential bugs ho·∫∑c issues
3. Performance optimization suggestions
4. Security considerations (n·∫øu c√≥)
5. Suggestions for improvement

Tr·∫£ l·ªùi b·∫±ng ti·∫øng Vi·ªát v√† s·ª≠ d·ª•ng markdown formatting."""
        
        return await self.chat(prompt)
    
    async def explain_concept(self, concept: str, level: str = "intermediate") -> AgentResponse:
        """
        Gi·∫£i th√≠ch concept m·ªôt c√°ch chi ti·∫øt.
        
        Args:
            concept: Kh√°i ni·ªám c·∫ßn gi·∫£i th√≠ch
            level: M·ª©c ƒë·ªô (beginner, intermediate, advanced)
            
        Returns:
            AgentResponse v·ªõi gi·∫£i th√≠ch
        """
        prompt = f"""H√£y gi·∫£i th√≠ch kh√°i ni·ªám "{concept}" ·ªü m·ª©c ƒë·ªô {level}.

Vui l√≤ng bao g·ªìm:
1. ƒê·ªãnh nghƒ©a r√µ r√†ng
2. T·∫°i sao concept n√†y quan tr·ªçng
3. Examples th·ª±c t·∫ø
4. Use cases ph·ªï bi·∫øn
5. Related concepts

Tr·∫£ l·ªùi b·∫±ng ti·∫øng Vi·ªát, d·ªÖ hi·ªÉu v√† c√≥ structure r√µ r√†ng."""
        
        return await self.chat(prompt)
    
    async def solve_problem(self, problem: str, context: str = "") -> AgentResponse:
        """
        Gi·∫£i quy·∫øt v·∫•n ƒë·ªÅ v·ªõi reasoning step-by-step.
        
        Args:
            problem: V·∫•n ƒë·ªÅ c·∫ßn gi·∫£i quy·∫øt
            context: Context b·ªï sung
            
        Returns:
            AgentResponse v·ªõi solution
        """
        prompt = f"""V·∫•n ƒë·ªÅ: {problem}

{f"Context: {context}" if context else ""}

H√£y gi·∫£i quy·∫øt v·∫•n ƒë·ªÅ n√†y v·ªõi approach step-by-step:
1. Ph√¢n t√≠ch v·∫•n ƒë·ªÅ
2. Identify key factors
3. Brainstorm solutions
4. Evaluate options
5. Recommend best solution
6. Implementation steps

S·ª≠ d·ª•ng reasoning logic v√† tr·∫£ l·ªùi b·∫±ng ti·∫øng Vi·ªát."""
        
        return await self.chat(prompt)
    
    async def close(self):
        """ƒê√≥ng connection."""
        await self.client.aclose()
    
    @property
    def info(self) -> Dict[str, Any]:
        """Th√¥ng tin chi ti·∫øt v·ªÅ DeepSeek agent."""
        base_info = super().info
        base_info.update({
            "model": self.config.model,
            "provider": "Together.xyz",
            "max_tokens": self.config.max_tokens,
            "temperature": self.config.temperature,
            "capabilities": [
                "Advanced reasoning",
                "Code analysis",
                "Problem solving", 
                "Vietnamese support",
                "Streaming responses"
            ]
        })
        return base_info


def create_deepseek_agent(api_key: Optional[str] = None) -> DeepSeekAgent:
    """
    Factory function ƒë·ªÉ t·∫°o DeepSeek agent.
    
    Args:
        api_key: Together.xyz API key (n·∫øu None s·∫Ω l·∫•y t·ª´ config)
        
    Returns:
        DeepSeekAgent instance
    """
    if api_key is None:
        api_key = config.TOGETHER_API_KEY
        
    if not api_key:
        raise ValueError("TOGETHER_API_KEY environment variable ho·∫∑c api_key parameter l√† required")
    
    deepseek_config = DeepSeekConfig(
        api_key=api_key,
        base_url=config.TOGETHER_BASE_URL,
        model=config.DEEPSEEK_MODEL,
        max_tokens=config.DEEPSEEK_MAX_TOKENS,
        temperature=config.DEEPSEEK_TEMPERATURE
    )
    return DeepSeekAgent(deepseek_config)

```

## File ../polymind/backend\agents\manager.py:
```python
# Generated by Copilot
"""
Agent Manager - Qu·∫£n l√Ω t·∫•t c·∫£ agents trong PolyMind system

Centralized management cho t·∫•t c·∫£ AI agents.
"""

import os
from typing import Dict, List, Optional, Any
from dataclasses import dataclass

from . import BaseAgent, AgentType, AgentResponse
from .deepseek import DeepSeekAgent, create_deepseek_agent


@dataclass
class AgentInfo:
    """Th√¥ng tin v·ªÅ m·ªôt agent."""
    name: str
    type: AgentType
    description: str
    is_available: bool
    capabilities: List[str]
    model_info: Optional[Dict[str, Any]] = None


class AgentManager:
    """
    Manager ƒë·ªÉ qu·∫£n l√Ω v√† route requests ƒë·∫øn c√°c agents.
    
    Ch·ª©c nƒÉng:
    - Registry c√°c agents
    - Route messages ƒë·∫øn appropriate agent
    - Load balancing v√† fallback
    - Agent health monitoring
    """
    
    def __init__(self):
        self.agents: Dict[str, BaseAgent] = {}
        self._default_agent: Optional[str] = None
    
    def register_agent(self, agent_id: str, agent: BaseAgent, is_default: bool = False):
        """
        ƒêƒÉng k√Ω agent v√†o manager.
        
        Args:
            agent_id: Unique ID cho agent
            agent: BaseAgent instance
            is_default: C√≥ ph·∫£i default agent kh√¥ng
        """
        self.agents[agent_id] = agent
        
        if is_default or self._default_agent is None:
            self._default_agent = agent_id
    
    def get_agent(self, agent_id: Optional[str] = None) -> Optional[BaseAgent]:
        """
        L·∫•y agent theo ID.
        
        Args:
            agent_id: ID c·ªßa agent (None = default agent)
            
        Returns:
            BaseAgent instance ho·∫∑c None        """
        if agent_id is None:
            agent_id = self._default_agent
            
        if agent_id is None:
            return None
            
        return self.agents.get(agent_id)
    
    def list_agents(self) -> List[AgentInfo]:
        """Li·ªát k√™ t·∫•t c·∫£ agents c√≥ s·∫µn."""
        agent_infos = []
        
        for agent_id, agent in self.agents.items():
            info = agent.info
            agent_info = AgentInfo(
                name=info["name"],
                type=AgentType(info["type"]),
                description=info["description"],
                is_available=True,  # TODO: Implement health check
                capabilities=info.get("capabilities", []),
                model_info={
                    "model": info.get("model"),
                    "provider": info.get("provider")
                }
            )
            agent_infos.append(agent_info)
        
        return agent_infos
    
    async def chat(self, message: str, agent_id: Optional[str] = None, **kwargs) -> AgentResponse:
        """
        G·ª≠i message ƒë·∫øn agent.
        
        Args:
            message: Tin nh·∫Øn t·ª´ user
            agent_id: ID c·ªßa agent (None = default)
            **kwargs: Tham s·ªë b·ªï sung
            
        Returns:
            AgentResponse
        """
        agent = self.get_agent(agent_id)
        
        if agent is None:
            # Fallback response
            return AgentResponse(
                content="Xin l·ªói, agent kh√¥ng kh·∫£ d·ª•ng. Vui l√≤ng th·ª≠ l·∫°i sau.",
                agent_type=AgentType.GENERAL,
                model_name="fallback",
                metadata={"error": True, "reason": "agent_unavailable"}
            )
        
        return await agent.chat(message, **kwargs)
    
    async def setup_default_agents(self):
        """Thi·∫øt l·∫≠p c√°c agents m·∫∑c ƒë·ªãnh."""
        try:
            # DeepSeek agent (primary)
            deepseek_agent = create_deepseek_agent()
            self.register_agent("deepseek", deepseek_agent, is_default=True)
            
            print("‚úÖ DeepSeek agent registered successfully")
            
        except Exception as e:
            print(f"‚ùå Failed to setup DeepSeek agent: {e}")
            print("üí° H√£y ƒë·∫£m b·∫£o TOGETHER_API_KEY environment variable ƒë∆∞·ª£c set")
    
    async def health_check(self) -> Dict[str, Any]:
        """Ki·ªÉm tra health c·ªßa t·∫•t c·∫£ agents."""
        health_status = {
            "total_agents": len(self.agents),
            "healthy_agents": 0,
            "agents": {}
        }
        
        for agent_id, agent in self.agents.items():
            try:
                # Simple health check b·∫±ng c√°ch g·ªçi info
                agent_info = agent.info
                health_status["agents"][agent_id] = {
                    "status": "healthy",
                    "info": agent_info
                }
                health_status["healthy_agents"] += 1
                
            except Exception as e:                health_status["agents"][agent_id] = {
                    "status": "unhealthy",
                    "error": str(e)
                }
        
        return health_status
    
    async def close_all(self):
        """ƒê√≥ng t·∫•t c·∫£ agents."""
        for agent in self.agents.values():
            if hasattr(agent, 'close') and callable(getattr(agent, 'close', None)):
                try:
                    close_method = getattr(agent, 'close')
                    await close_method()
                except Exception as e:
                    print(f"Error closing agent: {e}")
    
    def get_agent_by_type(self, agent_type: AgentType) -> Optional[BaseAgent]:
        """L·∫•y agent theo type."""
        for agent in self.agents.values():
            if agent.agent_type == agent_type:
                return agent
        return None
    
    def get_capabilities(self) -> Dict[str, List[str]]:
        """L·∫•y capabilities c·ªßa t·∫•t c·∫£ agents."""
        capabilities = {}
        
        for agent_id, agent in self.agents.items():
            info = agent.info
            capabilities[agent_id] = info.get("capabilities", [])
        
        return capabilities


# Global agent manager instance
agent_manager = AgentManager()

```

## File ../polymind/backend\agents\__init__.py:
```python
# Generated by Copilot
"""
PolyMind Agent System - Base Agent Interface

ƒê·ªãnh nghƒ©a interface c∆° b·∫£n cho t·∫•t c·∫£ agents trong h·ªá th·ªëng.
"""

from abc import ABC, abstractmethod
from typing import Dict, List, Optional, Any, AsyncGenerator
from dataclasses import dataclass
from enum import Enum
import asyncio
import time


class AgentType(Enum):
    """Lo·∫°i agent trong h·ªá th·ªëng."""
    GENERAL = "general"
    CODING = "coding" 
    ANALYSIS = "analysis"
    CREATIVE = "creative"
    DEEPSEEK = "deepseek"


class MessageRole(Enum):
    """Vai tr√≤ trong conversation."""
    USER = "user"
    ASSISTANT = "assistant"
    SYSTEM = "system"


@dataclass
class AgentMessage:
    """Tin nh·∫Øn trong conversation."""
    role: MessageRole
    content: str
    timestamp: float
    metadata: Optional[Dict[str, Any]] = None


@dataclass 
class AgentResponse:
    """Response t·ª´ agent."""
    content: str
    agent_type: AgentType
    model_name: str
    usage: Optional[Dict[str, Any]] = None
    metadata: Optional[Dict[str, Any]] = None
    timestamp: Optional[float] = None
    
    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = time.time()


class BaseAgent(ABC):
    """Base class cho t·∫•t c·∫£ agents."""
    
    def __init__(self, agent_type: AgentType, name: str, description: str):
        self.agent_type = agent_type
        self.name = name
        self.description = description
        self.conversation_history: List[AgentMessage] = []
    
    @abstractmethod
    async def chat(self, message: str, **kwargs) -> AgentResponse:
        """
        G·ª≠i tin nh·∫Øn ƒë·∫øn agent v√† nh·∫≠n response.
        
        Args:
            message: Tin nh·∫Øn t·ª´ user
            **kwargs: C√°c tham s·ªë b·ªï sung
            
        Returns:
            AgentResponse v·ªõi n·ªôi dung ph·∫£n h·ªìi
        """
        pass
    
    @abstractmethod
    async def stream_chat(self, message: str, **kwargs) -> AsyncGenerator[str, None]:
        """
        Stream response t·ª´ agent.
        
        Args:
            message: Tin nh·∫Øn t·ª´ user
            **kwargs: C√°c tham s·ªë b·ªï sung
            
        Yields:
            T·ª´ng ph·∫ßn c·ªßa response
        """
        pass
    
    def add_message(self, role: MessageRole, content: str, metadata: Optional[Dict] = None):
        """Th√™m tin nh·∫Øn v√†o l·ªãch s·ª≠ conversation."""
        message = AgentMessage(
            role=role,
            content=content,
            timestamp=time.time(),
            metadata=metadata
        )
        self.conversation_history.append(message)
    
    def clear_conversation(self):
        """X√≥a l·ªãch s·ª≠ conversation."""
        self.conversation_history.clear()
    
    def get_conversation_context(self, max_messages: int = 10) -> List[Dict[str, str]]:
        """
        L·∫•y context conversation cho API calls.
        
        Args:
            max_messages: S·ªë tin nh·∫Øn t·ªëi ƒëa ƒë·ªÉ l·∫•y
            
        Returns:
            List c√°c tin nh·∫Øn theo format API
        """
        recent_messages = self.conversation_history[-max_messages:]
        return [
            {"role": msg.role.value, "content": msg.content}
            for msg in recent_messages
        ]
    
    def get_system_prompt(self) -> str:
        """L·∫•y system prompt cho agent."""
        return f"You are {self.name}, {self.description}"
    
    @property
    def info(self) -> Dict[str, Any]:
        """Th√¥ng tin v·ªÅ agent."""
        return {
            "name": self.name,
            "type": self.agent_type.value,
            "description": self.description,
            "conversation_length": len(self.conversation_history)
        }

```

## File ../polymind/backend\core\lifecycle.py:
```python
"""
Application Lifecycle Manager for PolyMind (Optimized)

C·∫£i ti·∫øn ch√≠nh:
1. T√≠ch h·ª£p h·ªá th·ªëng logging hi·ªáu su·∫•t cao
2. X·ª≠ l√Ω lifecycle ch·∫∑t ch·∫Ω
3. Qu·∫£n l√Ω t√†i nguy√™n t·ª± ƒë·ªông
4. X·ª≠ l√Ω l·ªói to√†n di·ªán
"""

from contextlib import asynccontextmanager
from typing import AsyncGenerator

from fastapi import FastAPI

from ..agents.manager import agent_manager
from ..config import config
from backend.utils.logger import AsyncLoggerConfig, get_async_logger
import logging

# Kh·ªüi t·∫°o logger v·ªõi c·∫•u h√¨nh n√¢ng cao
logger = get_async_logger(__name__)


class LifecycleManager:
    """
    Qu·∫£n l√Ω v√≤ng ƒë·ªùi ·ª©ng d·ª•ng v·ªõi t√≠ch h·ª£p logging m·∫°nh m·∫Ω

    C·∫£i ti·∫øn:
    - S·ª≠ d·ª•ng logger ƒë·ªìng b·ªô hi·ªáu su·∫•t cao
    - X·ª≠ l√Ω l·ªói to√†n di·ªán
    - ƒê·∫£m b·∫£o gi·∫£i ph√≥ng t√†i nguy√™n
    - T√≠ch h·ª£p c·∫•u h√¨nh logging
    """

    def __init__(self):
        self._logger = logger

    async def startup(self):
        """X·ª≠ l√Ω t√°c v·ª• kh·ªüi ƒë·ªông ·ª©ng d·ª•ng"""
        try:
            self._logger.info("üöÄ Starting PolyMind application...")

            # C·∫•u h√¨nh logging n√¢ng cao
            AsyncLoggerConfig.configure_logging(
                level=logging.INFO,
                log_file_path="polymind.log",
                max_bytes=20 * 1024 * 1024,  # 20MB
                backup_count=10,
                buffer_capacity=500,
            )

            # Ki·ªÉm tra m√¥i tr∆∞·ªùng
            await self._validate_environment()

            # Kh·ªüi t·∫°o agents
            await self._initialize_agents()

            self._logger.info("‚úÖ Application startup completed")
        except Exception as e:
            self._logger.exception("üî• Critical startup failure")
            raise

    async def shutdown(self):
        """X·ª≠ l√Ω t√°c v·ª• t·∫Øt ·ª©ng d·ª•ng"""
        try:
            self._logger.info("üõë Shutting down PolyMind application...")

            # ƒê√≥ng t·∫•t c·∫£ agents
            await agent_manager.close_all()
            self._logger.info("‚úÖ All agents closed")

            # D·ª™NG LOG LISTENER - QUAN TR·ªåNG!
            AsyncLoggerConfig.stop_listener()
            self._logger.info("‚úÖ Logging system stopped")
        except Exception as e:
            self._logger.exception("‚ö†Ô∏è Graceful shutdown failed")
        finally:
            print("‚úÖ Application shutdown completed")

    async def _validate_environment(self):
        """Ki·ªÉm tra bi·∫øn m√¥i tr∆∞·ªùng v√† c·∫•u h√¨nh"""
        if not config.check_required_env():
            msg = "‚ö†Ô∏è Missing environment variables - Some features may be disabled"
            self._logger.warning(msg)
            print(msg)
        else:
            self._logger.info("‚úÖ Environment validation passed")

    async def _initialize_agents(self):
        """Kh·ªüi t·∫°o v√† c·∫•u h√¨nh agents"""
        try:
            await agent_manager.setup_default_agents()
            self._logger.info("‚úÖ Agent system initialized")
        except Exception as e:
            self._logger.error(f"‚ùå Agent initialization failed: {str(e)}")
            raise


# Global lifecycle manager instance
lifecycle_manager = LifecycleManager()


@asynccontextmanager
async def lifespan(app: FastAPI) -> AsyncGenerator[None, None]:
    """
    Qu·∫£n l√Ω v√≤ng ƒë·ªùi FastAPI v·ªõi x·ª≠ l√Ω l·ªói to√†n di·ªán

    C·∫£i ti·∫øn:
    - B·ªçc to√†n b·ªô lifecycle trong try-finally
    - X·ª≠ l√Ω exception chi ti·∫øt
    - ƒê·∫£m b·∫£o gi·∫£i ph√≥ng t√†i nguy√™n
    """
    try:
        await lifecycle_manager.startup()
        yield
    except Exception as e:
        logger.exception("üíÄ Fatal error in application lifespan")
        raise
    finally:
        await lifecycle_manager.shutdown()

```

## File ../polymind/backend\core\__init__.py:
```python
# Generated by Copilot
"""
Core Application Components

Package containing core application functionality and lifecycle management.
"""

from .lifecycle import lifecycle_manager, lifespan

__all__ = ["lifecycle_manager", "lifespan"]

```

## File ../polymind/backend\routes\chat.py:
```python
# Generated by Copilot
"""
Chat API Routes for PolyMind

REST API endpoints for chat functionality and agent management.
"""

from typing import List, Dict, Any
from fastapi import APIRouter, HTTPException

from ..agents.manager import agent_manager


router = APIRouter(prefix="/api/chat", tags=["chat"])


@router.get("/agents")
async def get_chat_agents() -> Dict[str, List[Dict[str, Any]]]:
    """
    Get available chat agents.

    Returns:
        Dict containing list of available agents with their info
    """
    agents = []

    for agent_id, agent_instance in agent_manager.agents.items():
        agent_info = agent_instance.info
        agents.append(
            {
                "id": agent_id,
                "name": agent_info["name"],
                "description": agent_info["description"],
                "type": agent_info["type"],
                "conversation_length": agent_info.get("conversation_length", 0),
            }
        )

    return {"agents": agents}


@router.get("/agents/health")
async def get_agents_health() -> Dict[str, Any]:
    """
    Ki·ªÉm tra health c·ªßa t·∫•t c·∫£ agents.

    Returns:
        Dict containing health status of all agents
    """
    try:
        health_status = await agent_manager.health_check()
        return health_status
    except Exception as e:
        raise HTTPException(
            status_code=500, detail=f"Error checking agent health: {str(e)}"
        )


@router.get("/agents/{agent_id}")
async def get_agent_details(agent_id: str) -> Dict[str, Any]:
    """
    Get detailed information about specific agent.

    Args:
        agent_id: ID of the agent to get details for

    Returns:
        Dict containing detailed agent information

    Raises:
        HTTPException: If agent not found
    """
    agent = agent_manager.get_agent(agent_id)
    if not agent:
        raise HTTPException(status_code=404, detail=f"Agent '{agent_id}' not found")

    return {
        "id": agent_id,
        "info": agent.info,
        "conversation_length": len(agent.conversation_history),
        "capabilities": agent.info.get("capabilities", []),
    }


@router.get("/agents/{agent_id}/conversation")
async def get_agent_conversation(agent_id: str, limit: int = 10) -> Dict[str, Any]:
    """
    Get conversation history for specific agent.

    Args:
        agent_id: ID of the agent
        limit: Maximum number of messages to return

    Returns:
        Dict containing conversation history

    Raises:
        HTTPException: If agent not found
    """
    agent = agent_manager.get_agent(agent_id)
    if not agent:
        raise HTTPException(status_code=404, detail=f"Agent '{agent_id}' not found")

    # Get recent conversation
    recent_messages = (
        agent.conversation_history[-limit:] if limit > 0 else agent.conversation_history
    )

    conversation = [
        {
            "role": msg.role.value,
            "content": msg.content,
            "timestamp": msg.timestamp,
            "metadata": msg.metadata,
        }
        for msg in recent_messages
    ]

    return {
        "agent_id": agent_id,
        "total_messages": len(agent.conversation_history),
        "returned_messages": len(conversation),
        "conversation": conversation,
    }


@router.delete("/agents/{agent_id}/conversation")
async def clear_agent_conversation(agent_id: str) -> Dict[str, str]:
    """
    Clear conversation history for specific agent.

    Args:
        agent_id: ID of the agent

    Returns:
        Success message

    Raises:
        HTTPException: If agent not found
    """
    agent = agent_manager.get_agent(agent_id)
    if not agent:
        raise HTTPException(status_code=404, detail=f"Agent '{agent_id}' not found")

    # Clear conversation
    agent.clear_conversation()

    return {"message": f"Conversation cleared for agent '{agent_id}'"}


@router.get("/stats")
async def get_chat_stats() -> Dict[str, Any]:
    """
    Get chat system statistics.

    Returns:
        Dict containing system statistics
    """
    from ..websocket.connection_manager import connection_manager

    # Get agent stats
    agent_stats = {}
    for agent_id, agent in agent_manager.agents.items():
        agent_stats[agent_id] = {
            "conversation_length": len(agent.conversation_history),
            "type": agent.agent_type.value,
            "name": agent.name,
        }

    # Get connection stats
    connection_stats = connection_manager.get_connection_info()

    return {
        "agents": agent_stats,
        "connections": connection_stats,
        "total_agents": len(agent_manager.agents),
    }

```

## File ../polymind/backend\routes\dashboard.py:
```python

```

## File ../polymind/backend\services\health.py:
```python
# backend/services/health.py
from fastapi import APIRouter

router = APIRouter(prefix="/health", tags=["health"])

@router.get("/")
async def health_check():
    return {
        "status": "healthy", 
        "timestamp": "2025-06-20T...",
        "version": "1.0.0"
    }

@router.get("/detailed")
async def detailed_health():
    return {
        "status": "healthy",
        "database": "connected",
        "memory_usage": "45%",
        "uptime": "2h 30m"
    }
```

## File ../polymind/backend\utils\logger.py:
```python
"""
High-Performance Async Logging System for PolyMind - Text Format (Optimized)

C·∫£i ti·∫øn ch√≠nh:
1. Th√™m RotatingFileHandler ƒë·ªÉ qu·∫£n l√Ω log file t·ª± ƒë·ªông
2. H·ªó tr·ª£ ghi log batch v·ªõi MemoryHandler
3. X·ª≠ l√Ω l·ªói m·∫°nh m·∫Ω cho listener
4. Qu·∫£n l√Ω t√†i nguy√™n ch·∫∑t ch·∫Ω khi d·ª´ng ·ª©ng d·ª•ng
5. H·ªó tr·ª£ context logging qua filters
"""

import logging
from logging.handlers import (
    QueueHandler,
    QueueListener,
    RotatingFileHandler,
    MemoryHandler,
)
import queue
import sys
import atexit
from typing import Optional


class AsyncLoggerConfig:
    """C·∫•u h√¨nh logger b·∫•t ƒë·ªìng b·ªô t·∫≠p trung"""

    _configured = False
    _loggers = {}
    _listener = None
    _file_handler = None
    _memory_handler = None

    @classmethod
    def configure_logging(
        cls,
        level: int = logging.INFO,
        format_string: Optional[str] = None,
        log_file_path: str = "./logs/polymind_system.log",
        max_bytes: int = 10 * 1024 * 1024,  # 10MB
        backup_count: int = 5,
        buffer_capacity: int = 1000,  # S·ªë b·∫£n ghi t·ªëi ƒëa trong b·ªô ƒë·ªám
        encoding: str = "utf-8",
    ) -> None:
        """
        C·∫•u h√¨nh to√†n c·ª•c cho h·ªá th·ªëng logging b·∫•t ƒë·ªìng b·ªô

        Args:
            level: M·ª©c logging (m·∫∑c ƒë·ªãnh: INFO)
            format_string: Chu·ªói ƒë·ªãnh d·∫°ng t√πy ch·ªânh
            log_file_path: ƒê∆∞·ªùng d·∫´n file log
            max_bytes: K√≠ch th∆∞·ªõc t·ªëi ƒëa m·ªói file log (bytes)
            backup_count: S·ªë file log d·ª± ph√≤ng
            buffer_capacity: Dung l∆∞·ª£ng b·ªô ƒë·ªám ghi batch
            encoding: M√£ h√≥a file log
        """
        if cls._configured:
            return

        # ƒê·ªãnh d·∫°ng m·∫∑c ƒë·ªãnh
        if format_string is None:
            format_string = "%(asctime)s - %(name)s - %(levelname)s - %(message)s"

        # T·∫°o queue cho logging (kh√¥ng gi·ªõi h·∫°n k√≠ch th∆∞·ªõc)
        log_queue = queue.Queue(-1)

        # T·∫°o RotatingFileHandler v·ªõi c∆° ch·∫ø xoay file
        cls._file_handler = RotatingFileHandler(
            log_file_path,
            maxBytes=max_bytes,
            backupCount=backup_count,
            encoding=encoding,
        )
        cls._file_handler.setFormatter(logging.Formatter(format_string))

        # Thi·∫øt l·∫≠p b·ªô ƒë·ªám ghi batch (n·∫øu ƒë∆∞·ª£c k√≠ch ho·∫°t)
        if buffer_capacity > 0:
            cls._memory_handler = MemoryHandler(
                capacity=buffer_capacity, target=cls._file_handler
            )
            final_handler = cls._memory_handler
        else:
            final_handler = cls._file_handler

        # T·∫°o QueueListener
        cls._listener = QueueListener(
            log_queue, final_handler, respect_handler_level=True
        )

        # C·∫•u h√¨nh root logger
        root_logger = logging.getLogger()
        root_logger.setLevel(level)

        # X√≥a m·ªçi handler hi·ªán c√≥ ƒë·ªÉ tr√°nh tr√πng l·∫∑p
        for handler in root_logger.handlers[:]:
            root_logger.removeHandler(handler)

        # Th√™m QueueHandler ƒë·ªÉ g·ª≠i log t·ªõi queue
        queue_handler = QueueHandler(log_queue)
        queue_handler.setLevel(level)
        root_logger.addHandler(queue_handler)

        # B·∫Øt ƒë·∫ßu listener trong thread ri√™ng
        cls._listener.start()
        cls._configured = True

    @classmethod
    def get_logger(cls, name: str) -> logging.Logger:
        """
        L·∫•y logger cho module ch·ªâ ƒë·ªãnh

        Args:
            name: T√™n logger (th∆∞·ªùng l√† __name__)

        Returns:
            Logger instance ƒë√£ ƒë∆∞·ª£c c·∫•u h√¨nh
        """
        if not cls._configured:
            cls.configure_logging()

        if name not in cls._loggers:
            logger = logging.getLogger(name)
            cls._loggers[name] = logger

        return cls._loggers[name]

    @classmethod
    def _handle_listener_error(cls, record):
        """X·ª≠ l√Ω l·ªói trong qu√° tr√¨nh ghi log"""
        sys.stderr.write(f"!!! L·ªñI LOGGING: Kh√¥ng th·ªÉ ghi b·∫£n ghi log - {record.msg}\n")
        sys.stderr.flush()

    @classmethod
    def stop_listener(cls) -> None:
        """D·ª´ng listener v√† gi·∫£i ph√≥ng t√†i nguy√™n"""
        if cls._listener:
            cls._listener.stop()

            # ƒê·∫£m b·∫£o flush b·ªô ƒë·ªám n·∫øu s·ª≠ d·ª•ng MemoryHandler
            if cls._memory_handler:
                cls._memory_handler.flush()
                cls._memory_handler.close()

            if cls._file_handler:
                cls._file_handler.close()

            cls._configured = False


# ƒêƒÉng k√Ω d·ª´ng listener khi ·ª©ng d·ª•ng k·∫øt th√∫c
atexit.register(AsyncLoggerConfig.stop_listener)


def get_async_logger(name: str) -> logging.Logger:
    """
    L·∫•y logger cho module ch·ªâ ƒë·ªãnh (API ti·ªán √≠ch)

    Args:
        name: T√™n logger (th∆∞·ªùng l√† __name__)

    Returns:
        Logger instance ƒë√£ ƒë∆∞·ª£c c·∫•u h√¨nh

    V√≠ d·ª•:
        from async_logger import get_async_logger
        logger = get_async_logger(__name__)
    """
    return AsyncLoggerConfig.get_logger(name)

```

## File ../polymind/backend\utils\__init__.py:
```python
# Generated by Copilot
"""Utility modules for the server."""

from .logger import get_async_logger

__all__ = ["get_async_logger"]

```

## File ../polymind/backend\websocket\chat_handler.py:
```python
# Generated by Copilot
"""
Chat WebSocket Handler for PolyMind

Handles WebSocket chat logic, message processing, and agent interactions.
"""

import json
from typing import Dict, Any
from datetime import datetime
from fastapi import WebSocket, WebSocketDisconnect

from ..agents.manager import agent_manager
from ..utils.logger import get_logger
from .connection_manager import connection_manager


class ChatHandler:
    """
    Handles WebSocket chat interactions and agent communication.

    Features:
    - Message parsing and validation
    - Agent routing and communication
    - Streaming and regular responses
    - Error handling and logging
    """

    def __init__(self):
        self._logger = None

    async def _get_logger(self):
        """Get or initialize logger for chat handler."""
        if self._logger is None:
            self._logger = await get_logger("polymind_chat")
        return self._logger

    async def handle_websocket(self, websocket: WebSocket):
        """
        Main WebSocket handler for chat connections.

        Args:
            websocket: WebSocket connection instance
        """
        await connection_manager.connect(websocket)
        logger = await self._get_logger()

        try:
            while True:
                # Receive and parse message
                data = await websocket.receive_text()
                message_data = json.loads(data)

                # Process the message
                await self._process_message(message_data, websocket, logger)

        except WebSocketDisconnect:
            await logger.info("üîå WebSocket client disconnected")
            await connection_manager.disconnect(websocket)
        except Exception as e:
            await logger.error(f"‚ùå WebSocket error: {str(e)}")
            await connection_manager.disconnect(websocket)

    async def _process_message(
        self, message_data: Dict[str, Any], websocket: WebSocket, logger
    ):
        """
        Process incoming chat message.

        Args:
            message_data: Parsed message data from client
            websocket: WebSocket connection
            logger: Logger instance
        """
        # Extract message information
        user_message = message_data.get("content", "")
        agent_id = message_data.get("agent", "deepseek")
        is_streaming = message_data.get("streaming", False)

        # Log incoming message
        message_preview = user_message[:100] + (
            "..." if len(user_message) > 100 else ""
        )
        await logger.info(
            f"üí¨ Received message for agent '{agent_id}' (streaming: {is_streaming}): {message_preview}"
        )

        try:
            if is_streaming:
                await self._handle_streaming_response(
                    user_message, agent_id, websocket, logger
                )
            else:
                await self._handle_regular_response(
                    user_message, agent_id, websocket, logger
                )

        except Exception as e:
            await logger.error(
                f"‚ùå Error processing message for agent '{agent_id}': {str(e)}"
            )
            await connection_manager.send_error(f"L·ªói x·ª≠ l√Ω: {str(e)}", websocket)

    async def _handle_streaming_response(
        self, user_message: str, agent_id: str, websocket: WebSocket, logger
    ):
        """
        Handle streaming response from agent.

        Args:
            user_message: User's message
            agent_id: Target agent ID
            websocket: WebSocket connection
            logger: Logger instance
        """
        # Send typing indicator
        await connection_manager.send_typing_indicator(agent_id, websocket)

        # Get agent and stream response
        agent = agent_manager.get_agent(agent_id)
        if not agent:
            await logger.error(f"‚ùå Agent '{agent_id}' kh√¥ng kh·∫£ d·ª•ng")
            await connection_manager.send_error(
                f"Agent '{agent_id}' kh√¥ng kh·∫£ d·ª•ng", websocket
            )
            return

        response_content = ""
        stream = await agent.stream_chat(user_message)

        async for chunk in stream:
            response_content += chunk
            await connection_manager.send_chunk(chunk, agent_id, websocket)
        # Send final response
        await connection_manager.send_response(
            response_content,
            agent_id,
            "deepseek-v3",  # Use fixed model name for now
            websocket,
        )

        # Log success
        await logger.info(
            f"‚úÖ Streaming response completed for agent '{agent_id}' - {len(response_content)} characters"
        )

    async def _handle_regular_response(
        self, user_message: str, agent_id: str, websocket: WebSocket, logger
    ):
        """
        Handle regular (non-streaming) response from agent.

        Args:
            user_message: User's message
            agent_id: Target agent ID
            websocket: WebSocket connection
            logger: Logger instance
        """
        # Get response from agent manager
        response = await agent_manager.chat(user_message, agent_id)

        # Send response
        await connection_manager.send_response(
            response.content, agent_id, response.model_name, websocket
        )

        # Log success
        await logger.info(
            f"‚úÖ Regular response completed for agent '{agent_id}' using model '{response.model_name}' - {len(response.content)} characters"
        )


# Global chat handler instance
chat_handler = ChatHandler()

```

## File ../polymind/backend\websocket\connection_manager.py:
```python
# Generated by Copilot
"""
WebSocket Connection Manager for PolyMind Chat

Manages WebSocket connections, message routing, and connection lifecycle.
"""

import json
from typing import List
from datetime import datetime
from fastapi import WebSocket


class ConnectionManager:
    """
    WebSocket connection manager for handling multiple chat connections.

    Features:
    - Connection lifecycle management
    - Message broadcasting and personal messaging
    - Connection logging and monitoring
    """

    def __init__(self):
        self.active_connections: List[WebSocket] = []

    async def connect(self, websocket: WebSocket):
        """Accept new WebSocket connection and add to active list."""
        await websocket.accept()
        self.active_connections.append(websocket)

        # Simple logging without complex async logger for now
        print(
            f"üîå New WebSocket connection established. Total connections: {len(self.active_connections)}"
        )

    async def disconnect(self, websocket: WebSocket):
        """Remove WebSocket from active connections."""
        if websocket in self.active_connections:
            self.active_connections.remove(websocket)

        print(
            f"üîå WebSocket connection closed. Remaining connections: {len(self.active_connections)}"
        )

    async def send_personal_message(self, message: str, websocket: WebSocket):
        """Send message to specific WebSocket connection."""
        try:
            await websocket.send_text(message)
        except Exception as e:
            print(f"‚ùå Failed to send message to websocket: {str(e)}")
            await self.disconnect(websocket)

    async def send_json_message(self, data: dict, websocket: WebSocket):
        """Send JSON message to specific WebSocket connection."""
        message = json.dumps(data, ensure_ascii=False)
        await self.send_personal_message(message, websocket)

    async def broadcast(self, message: str):
        """Broadcast message to all active connections."""
        failed_connections = []

        for connection in self.active_connections:
            try:
                await connection.send_text(message)
            except Exception:
                failed_connections.append(connection)

        # Remove failed connections
        for failed_conn in failed_connections:
            await self.disconnect(failed_conn)

    async def broadcast_json(self, data: dict):
        """Broadcast JSON message to all active connections."""
        message = json.dumps(data, ensure_ascii=False)
        await self.broadcast(message)

    async def send_typing_indicator(self, agent_id: str, websocket: WebSocket):
        """Send typing indicator for specific agent."""
        await self.send_json_message(
            {
                "type": "ai_typing",
                "agent": agent_id,
                "timestamp": datetime.now().isoformat(),
            },
            websocket,
        )

    async def send_chunk(self, chunk: str, agent_id: str, websocket: WebSocket):
        """Send streaming chunk to WebSocket."""
        await self.send_json_message(
            {
                "type": "ai_chunk",
                "content": chunk,
                "agent": agent_id,
                "timestamp": datetime.now().isoformat(),
            },
            websocket,
        )

    async def send_response(
        self, content: str, agent_id: str, model_name: str, websocket: WebSocket
    ):
        """Send complete AI response to WebSocket."""
        await self.send_json_message(
            {
                "type": "ai_response",
                "content": content,
                "agent": agent_id,
                "model": model_name,
                "timestamp": datetime.now().isoformat(),
            },
            websocket,
        )

    async def send_error(self, error_message: str, websocket: WebSocket):
        """Send error message to WebSocket."""
        await self.send_json_message(
            {
                "type": "error",
                "content": error_message,
                "timestamp": datetime.now().isoformat(),
            },
            websocket,
        )

    def get_connection_count(self) -> int:
        """Get number of active connections."""
        return len(self.active_connections)

    def get_connection_info(self) -> dict:
        """Get connection statistics."""
        return {
            "total_connections": len(self.active_connections),
            "status": "healthy" if self.active_connections else "no_connections",
        }


# Global connection manager instance
connection_manager = ConnectionManager()

```

## File ../polymind/backend\websocket\__init__.py:
```python
# Generated by Copilot
"""
WebSocket Connection Manager Package

Package for managing WebSocket connections in PolyMind chat system.
"""

from .connection_manager import ConnectionManager, connection_manager
from .chat_handler import ChatHandler, chat_handler

__all__ = ["ConnectionManager", "connection_manager", "ChatHandler", "chat_handler"]

```

